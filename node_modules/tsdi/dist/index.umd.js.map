{"version":3,"file":"index.umd.js","sources":["../lib/debug.ts","../lib/helper.ts","../lib/global-state.ts","../lib/component.ts","../lib/destroy.ts","../lib/external.ts","../lib/factory.ts","../lib/initialize.ts","../lib/inject.ts","../lib/configure.ts","../lib/tsdi.ts"],"sourcesContent":["/* istanbul ignore next */\nconst enabled = (() => {\n  const test = (str: string | undefined | null) => {\n    return (str || '').indexOf('tsdi') !== -1 || str === '*';\n  };\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    return test(process.env.DEBUG);\n  } else if (typeof window !== 'undefined') {\n    return test(window.localStorage.getItem('DEBUG'));\n  }\n  return false;\n})();\n\n/* istanbul ignore next */\nexport const debug = (_: string) => {\n  // tslint:disable-next-line:cyclomatic-complexity\n  const log = (template: string | Error, ...args: any[]) => {\n    if (!enabled) {\n      return;\n    }\n\n    if (template instanceof Error) {\n      console.error(template);\n      return;\n    }\n\n    const parts = [];\n    let arg = 0;\n    let pos = 0;\n    let idx = template.indexOf('%', pos);\n    while (idx !== -1) {\n      parts.push(template.substring(pos, idx));\n      switch (template.substr(idx, 2)) {\n        case '%o':\n          parts.push(args[arg++]);\n          break;\n        case '%s':\n          parts.push(String(args[arg++]));\n          break;\n      }\n      pos = idx + 2;\n      idx = template.indexOf('%', pos);\n    }\n    if (pos < template.length) {\n      parts.push(template.substring(pos));\n    }\n    console.log(...parts);\n  };\n  log.enabled = enabled;\n  return log;\n};\n","import { ComponentOrFactoryMetadata, FactoryMetadata } from './tsdi';\n\nexport function isFactoryMetadata(\n  metadata: ComponentOrFactoryMetadata\n): metadata is FactoryMetadata {\n  return Boolean((metadata as FactoryMetadata).rtti);\n}\n\nexport function findIndexOf<T>(\n  list: T[],\n  test: (element: T) => boolean\n): number {\n  let idx = -1;\n  for (let i = 0, n = list.length; i < n; i++) {\n    if (test(list[i])) {\n      idx = i;\n    }\n  }\n  return idx;\n}\n\nexport function removeElement<T>(\n  list: T[],\n  test: (element: T) => boolean\n): T[] {\n  const idx = findIndexOf(list, test);\n  if (idx > -1) {\n    return [...list.slice(0, idx), ...list.slice(idx + 1)];\n  }\n  return list;\n}\n\nexport function getNamedOptions<T extends { name?: string }>(\n  optionOrString: T | string\n): T {\n  if (typeof optionOrString === 'string') {\n    const named = {\n      name: optionOrString\n    };\n    return named as T;\n  }\n  return optionOrString;\n}\n","import { findIndexOf, removeElement } from './helper';\nimport { ComponentOrFactoryMetadata } from './tsdi';\n\nexport type ComponentListener = (\n  metadataOrExternal: ComponentOrFactoryMetadata | Function\n) => void;\n\nlet listeners: ComponentListener[] = [];\nconst knownComponents: ComponentOrFactoryMetadata[] = [];\nconst knownExternals: Function[] = [];\n\nexport function addKnownComponent(metadata: ComponentOrFactoryMetadata): void {\n  if (\n    metadata.options.name &&\n    findIndexOf(\n      knownComponents,\n      (meta) => meta.options.name === metadata.options.name\n    ) > -1\n  ) {\n    throw new Error(\n      `Duplicate name '${metadata.options.name}' for known Components.`\n    );\n  }\n  knownComponents.push(metadata);\n  listeners.forEach((listener) => listener(metadata));\n}\n\nexport function addKnownExternal(external: Function): void {\n  if (!isKnownExternal(external)) {\n    knownExternals.push(external);\n    listeners.forEach((listener) => listener(external));\n  }\n}\n\nexport function isKnownExternal(external: Function): boolean {\n  return findIndexOf(knownExternals, (fn) => fn === external) !== -1;\n}\n\nexport function addListener(listener: ComponentListener): void {\n  listeners.push(listener);\n  knownComponents.forEach((metadata) => listener(metadata));\n  knownExternals.forEach((external) => listener(external));\n}\n\nexport function removeListener(listener: ComponentListener): void {\n  listeners = removeElement(listeners, (l) => l === listener);\n}\n","import { debug } from './debug';\nimport { addKnownComponent } from './global-state';\nimport { getNamedOptions } from './helper';\nimport { IComponentOptions } from './tsdi';\n\nconst log = debug('tsdi');\n\nexport function Component<TFunction extends Function>(\n  target: TFunction\n): TFunction;\nexport function Component(\n  optionsOrString?: IComponentOptions | string\n): ClassDecorator;\nexport function Component<TFunction extends Function>(\n  ...args: any[]\n): ClassDecorator | TFunction {\n  const decorate = (\n    target: TFunction,\n    optionsOrString: IComponentOptions | string = {}\n  ) => {\n    log(`@Component ${(target as any).name}`);\n    const options = getNamedOptions<IComponentOptions>(optionsOrString);\n    addKnownComponent({\n      fn: target as any,\n      options\n    });\n    Reflect.defineMetadata('component:options', options, target);\n    return target;\n  };\n\n  if (args.length === 1 && typeof args[0] === 'function') {\n    return decorate(args[0], {});\n  }\n  return function(target: TFunction): TFunction {\n    return decorate(target, args[0] || {});\n  } as ClassDecorator;\n}\nexport const component = Component;\n","import { debug } from './debug';\nconst log = debug('tsdi');\n\nexport function Destroy(target: Object, propertyKey: string): void;\nexport function Destroy(): MethodDecorator;\nexport function Destroy(...args: any[]): MethodDecorator | void {\n  const decorate = (target: Object, propertyKey: symbol | string) => {\n    log('@Destroy %s#%s', (target.constructor as any).name, propertyKey);\n    Reflect.defineMetadata('component:destroy', propertyKey, target);\n  };\n  if (args.length > 0) {\n    return decorate(args[0], args[1]);\n  }\n  return function(target: Object, propertyKey: symbol | string): void {\n    decorate(target, propertyKey);\n  };\n}\nexport const destroy = Destroy;\n","import { debug } from './debug';\nimport { addKnownExternal } from './global-state';\n\nconst log = debug('tsdi');\n\nexport function External<TFunction extends Function>(\n  target: TFunction\n): TFunction;\nexport function External(): ClassDecorator;\nexport function External<TFunction extends Function>(\n  ...args: any[]\n): ClassDecorator | TFunction {\n  const decorate = (target: TFunction) => {\n    log(`@External ${target.name}`);\n    addKnownExternal(target);\n\n    const constructor = function (this: any, ...args: any[]): any {\n      return (target as any).__tsdi__.configureExternal(args, target);\n    };\n    Object.defineProperty(constructor, 'name', {\n      value: target.name,\n    });\n    Object.defineProperty(constructor, '__tsdi__external__', {\n      value: target,\n    });\n    (constructor as any).displayName = target.name;\n    Object.getOwnPropertyNames(target)\n      .filter(\n        (prop) =>\n          prop !== 'name' &&\n          prop !== 'length' &&\n          prop !== 'caller' &&\n          prop !== 'callee' &&\n          prop !== 'arguments' &&\n          !(constructor as any)[prop]\n      )\n      .forEach((prop) => ((constructor as any)[prop] = (target as any)[prop]));\n    constructor.prototype = target.prototype;\n    return constructor as any;\n  };\n\n  if (args.length > 0) {\n    return decorate(args[0]);\n  }\n  return function (target: TFunction): TFunction {\n    return decorate(target);\n  } as ClassDecorator;\n}\nexport const external = External;\n","import { debug } from './debug';\nimport { addKnownComponent } from './global-state';\nimport { IFactoryOptions } from './tsdi';\n\nconst log = debug('tsdi');\n\nexport function Factory(target: Object, propertyKey: string): void;\nexport function Factory(options?: IFactoryOptions): MethodDecorator;\nexport function Factory(...args: any[]): MethodDecorator | void {\n  const decorate = (\n    target: Object,\n    propertyKey: string | symbol,\n    options: IFactoryOptions\n  ) => {\n    if (log.enabled) {\n      log(\n        '@Factory %s#%s({name: \"%s\"})',\n        (target.constructor as any).name,\n        propertyKey,\n        (target as any)[propertyKey].name\n      );\n    }\n    addKnownComponent({\n      target,\n      property: propertyKey.toString(),\n      options,\n      rtti: Reflect.getMetadata('design:returntype', target, propertyKey)\n    });\n  };\n\n  if (args.length > 1) {\n    return decorate(args[0], args[1], {});\n  }\n  const options = args[0] || {};\n  return function(target: Object, propertyKey: string | symbol): void {\n    decorate(target, propertyKey, options);\n  };\n}\nexport const factory = Factory;\n","import { debug } from './debug';\nconst log = debug('tsdi');\n\nexport function Initialize(target: Object, propertyKey: string): void;\nexport function Initialize(): MethodDecorator;\nexport function Initialize(...args: any[]): MethodDecorator | void {\n  const decorate = (target: Object, propertyKey: string | symbol) => {\n    log('@Initialize %s#%s', (target.constructor as any).name, propertyKey);\n    Reflect.defineMetadata('component:init', propertyKey, target);\n\n    const isAsync = Reflect.getMetadata('design:returntype', target, propertyKey) === Promise;\n    Reflect.defineMetadata('component:init:async', isAsync, target);\n  };\n  if (args.length > 0) {\n    return decorate(args[0], args[1]);\n  }\n  return function(target: Object, propertyKey: string | symbol): void {\n    decorate(target, propertyKey);\n  };\n}\nexport const initialize = Initialize;\n","import { debug } from './debug';\nimport { getNamedOptions } from './helper';\nimport {\n  Constructable,\n  IInjectOptions,\n  InjectMetadata,\n  ParameterMetadata\n} from './tsdi';\n\nconst log = debug('tsdi');\n\nexport function Inject(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex?: number\n): void;\nexport function Inject(\n  optionsOrString?: IInjectOptions | string\n): PropertyDecorator & ParameterDecorator;\nexport function Inject(\n  ...args: any[]\n): PropertyDecorator & ParameterDecorator | void {\n  const defaultOptions = (optionsOrString?: IInjectOptions | string) => {\n    const options = getNamedOptions<IInjectOptions>(optionsOrString || {});\n    if (options.lazy === undefined) {\n      options.lazy = true;\n    }\n    return options;\n  };\n  const decorateProperty = (\n    target: Object,\n    propertyKey: string | symbol,\n    options: IInjectOptions\n  ) => {\n    log(`@Inject ${(target.constructor as any).name}#${String(propertyKey)}`);\n    const type: Constructable<any> = Reflect.getMetadata(\n      'design:type',\n      target,\n      propertyKey\n    );\n    let injects: InjectMetadata[] = Reflect.getMetadata(\n      'component:injects',\n      target\n    );\n    if (!injects) {\n      injects = [];\n      Reflect.defineMetadata('component:injects', injects, target);\n    }\n    injects.push({\n      target,\n      property: propertyKey.toString(),\n      options,\n      type\n    });\n  };\n  const decorateParameter = (\n    target: Object,\n    propertyKey: string | symbol,\n    parameterIndex: number,\n    options: IInjectOptions\n  ) => {\n    log(`@Inject ${String(propertyKey)}`);\n    let parameters: ParameterMetadata[] = Reflect.getMetadata(\n      'component:parameters',\n      target\n    );\n    if (!parameters) {\n      parameters = [];\n      Reflect.defineMetadata('component:parameters', parameters, target);\n    }\n    parameters.push({\n      options,\n      index: parameterIndex,\n      rtti: Reflect.getMetadata('design:paramtypes', target)[parameterIndex]\n    });\n  };\n\n  if (args.length > 1) {\n    const options = defaultOptions({});\n    if (typeof args[2] === 'undefined') {\n      decorateProperty(args[0], args[1], options);\n    } else {\n      decorateParameter(args[0], args[1], args[2], options);\n    }\n    return;\n  }\n  return function(\n    target: Object,\n    propertyKey: string | symbol,\n    parameterIndex?: number\n  ): void {\n    const options = defaultOptions(args[0] || {});\n    if (typeof parameterIndex === 'undefined') {\n      return decorateProperty(target, propertyKey, options);\n    } else {\n      return decorateParameter(target, propertyKey, parameterIndex, options);\n    }\n  };\n}\nexport const inject = Inject;\n","import { Constructable, TSDI } from '.';\n\nexport function Configure(target: Object, property: string | symbol): any;\nexport function Configure(): any;\nexport function Configure(...args: any[]): any {\n  const decorate = (\n    target: Record<string, Function>,\n    property: string | symbol\n  ) => {\n    Reflect.defineMetadata('component:configured', true, target, property);\n\n    const orig = target[property.toString()];\n    const cacheKey = `__tsdi__${property.toString()}__`;\n\n    const methodReturnType = Reflect.getMetadata(\n      'design:returntype',\n      target,\n      property\n    );\n    const propertyType = Reflect.getMetadata('design:type', target, property);\n\n    function propertyCreator(this: {\n      __tsdi__: TSDI;\n      [cacheKey: string]: any;\n    }): any {\n      if (!methodReturnType) {\n        return this.__tsdi__.get(propertyType);\n      }\n\n      if (cacheKey in this) {\n        return this[cacheKey];\n      }\n\n      const values = Reflect.getMetadata(\n        'design:paramtypes',\n        target,\n        property\n      ).map((param: Constructable<unknown>) => this.__tsdi__.get(param));\n\n      const value = orig.call(this, ...values);\n      Object.defineProperty(this, cacheKey, {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value,\n      });\n      return value;\n    }\n\n    return {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: propertyCreator,\n    };\n  };\n  if (args.length > 0) {\n    return decorate(args[0], args[1]);\n  }\n  return (target: Object, property: string | symbol) => {\n    return decorate(target as any, property) as any;\n  };\n}\n\nexport { Configure as configure };\n","import 'reflect-metadata';\nimport { debug } from './debug';\nimport { addListener, ComponentListener, removeListener } from './global-state';\nimport { findIndexOf, isFactoryMetadata } from './helper';\n\nconst log = debug('tsdi');\n\nexport type Constructable<T> = { new (...args: any[]): T };\n\nexport type IComponentOptions = ComponentOptions;\nexport interface ComponentOptions {\n  name?: string;\n  singleton?: boolean;\n  eager?: boolean;\n  scope?: string;\n}\n\nexport type IInjectOptions = InjectOptions;\nexport interface InjectOptions {\n  name?: string;\n  lazy?: boolean;\n  dynamic?: boolean;\n}\n\nexport type IFactoryOptions = FactoryOptions;\nexport interface FactoryOptions {\n  name?: string;\n  singleton?: boolean;\n  eager?: boolean;\n}\n\n/** @internal */\nexport type InjectMetadata = {\n  target: Object;\n  property: string;\n  options: IInjectOptions;\n  type: Constructable<any>;\n};\n\n/** @internal */\nexport type ParameterMetadata = {\n  index: number;\n  rtti: Constructable<any>;\n  options: IInjectOptions;\n};\n\n/** @internal */\nexport type ComponentMetadata = {\n  fn: Constructable<any>;\n  options: IComponentOptions;\n};\n\n/** @internal */\nexport type FactoryMetadata = {\n  target: Object;\n  property: string;\n  options: IFactoryOptions;\n  rtti: Constructable<any>;\n};\n\n/** @internal */\nexport type ComponentOrFactoryMetadata = ComponentMetadata | FactoryMetadata;\n\nexport type Mock<T> = { -readonly [P in keyof T]: T[P] };\n\nexport interface LifecycleListener {\n  onCreate?(component: any): void;\n  onReady?(component: any): void;\n  onDestroy?(component: any): void;\n}\n\nexport class TSDI {\n  private autoMock: any[] | undefined = undefined;\n\n  private readonly components: ComponentOrFactoryMetadata[] = [];\n\n  private instances: { [idx: number]: Object } = {};\n\n  private listener: ComponentListener | undefined;\n\n  private readonly properties: { [key: string]: any } = {};\n\n  private readonly lifecycleListeners: LifecycleListener[] = [];\n\n  private readonly scopes: { [name: string]: boolean } = {};\n\n  private readonly parent: TSDI | undefined;\n\n  constructor(configuration?: Object, parent?: TSDI) {\n    this.registerComponent({\n      fn: TSDI,\n      options: {},\n    });\n    this.instances[0] = this;\n\n    if (configuration) {\n      this.registerComponent({\n        fn: configuration.constructor as Constructable<unknown>,\n        options: {},\n      });\n      this.instances[1] = configuration;\n      Object.defineProperty(configuration, '__tsdi__', {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value: this,\n      });\n\n      Object.getOwnPropertyNames(configuration.constructor.prototype)\n        .filter((name) =>\n          Reflect.getMetadata(\n            'component:configured',\n            configuration.constructor.prototype,\n            name\n          )\n        )\n        .forEach((property) => {\n          const rtti = Reflect.getMetadata(\n            'design:returntype',\n            configuration,\n            property\n          );\n          if (rtti) {\n            // method\n            this.registerComponent({\n              target: configuration,\n              property,\n              options: {},\n              rtti,\n            });\n          } else {\n            const fn = Reflect.getMetadata(\n              'design:type',\n              configuration,\n              property\n            );\n            if (fn.__tsdi__external__) {\n              // external component\n              fn.__tsdi__external__.__tsdi__ = this;\n            } else {\n              // property component\n              this.registerComponent({\n                fn,\n                options: {},\n              });\n            }\n          }\n        });\n    }\n    this.parent = parent;\n  }\n\n  public addLifecycleListener(\n    lifecycleListener: LifecycleListener\n  ): () => void {\n    this.lifecycleListeners.push(lifecycleListener);\n    Object.keys(this.instances).forEach((idx) =>\n      this.notifyOnCreate(this.instances[parseInt(idx, 10)])\n    );\n\n    Object.values(this.instances)\n      .map(\n        (instance) => [instance, this.getInitializerPromise(instance)] as const\n      )\n      .forEach(([instance, promise]) =>\n        promise?.then(() => this.notifyOnReady(instance))\n      );\n\n    return () => {\n      const idx = this.lifecycleListeners.findIndex(\n        (l) => l === lifecycleListener\n      );\n      this.lifecycleListeners.splice(idx, 1);\n    };\n  }\n\n  private notifyOnCreate(component: any): void {\n    this.lifecycleListeners.forEach((l) => l.onCreate?.(component));\n  }\n\n  private notifyOnReady(component: any): void {\n    this.lifecycleListeners.forEach((l) => l.onReady?.(component));\n  }\n\n  private notifyOnDestroy(component: any): void {\n    this.lifecycleListeners.forEach((l) => l.onDestroy?.(component));\n  }\n\n  public addProperty(key: string, value: any): void {\n    this.properties[key] = value;\n  }\n\n  public close(): void {\n    Object.keys(this.instances).forEach((key) => {\n      const idx = parseInt(key, 10);\n      const metadata = this.components[idx];\n      if (!isFactoryMetadata(metadata)) {\n        this.destroyInstance(idx, metadata);\n      }\n    });\n    this.instances = [];\n\n    if (this.listener) {\n      removeListener(this.listener);\n      this.listener = undefined;\n    }\n  }\n\n  private destroyInstance(\n    idx: number,\n    metadata: ComponentOrFactoryMetadata\n  ): void {\n    const instance = this.instances[idx];\n    if (instance) {\n      this.notifyOnDestroy(instance);\n\n      const destroy = Reflect.getMetadata(\n        'component:destroy',\n        isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn.prototype\n      );\n      if (destroy && (instance as any)[destroy]) {\n        (instance as any)[destroy].call(instance);\n      }\n      (this.instances[idx] as any) = undefined;\n    }\n  }\n\n  public enableComponentScanner(): void {\n    if (!this.listener) {\n      this.listener = (\n        metadataOrExternal: Parameters<ComponentListener>[0]\n      ) => {\n        if (typeof metadataOrExternal === 'function') {\n          (metadataOrExternal as any).__tsdi__ = this;\n        } else {\n          this.registerComponent(metadataOrExternal);\n        }\n      };\n      if (this.listener) {\n        addListener(this.listener);\n      }\n    }\n  }\n\n  public enableAutomock(...allowedDependencies: any[]): void {\n    console.warn(\n      '#enableAutomock is deprecated and should not be used. Instead use #override.'\n    );\n    this.autoMock = allowedDependencies;\n  }\n\n  private registerComponent(\n    componentMetadata: ComponentOrFactoryMetadata\n  ): void {\n    if (this.components.indexOf(componentMetadata) === -1) {\n      if (\n        componentMetadata.options.name &&\n        findIndexOf(\n          this.components,\n          (meta) => meta.options.name === componentMetadata.options.name\n        ) > -1\n      ) {\n        console.warn(\n          `Component with name '${componentMetadata.options.name}' already registered.`\n        );\n      }\n\n      this.markAsyncInitializer(componentMetadata);\n\n      log(\n        'registerComponent %o',\n        isFactoryMetadata(componentMetadata)\n          ? (componentMetadata.rtti as any).name\n          : (componentMetadata.fn as any).name\n      );\n      this.components.push(componentMetadata);\n      if (componentMetadata.options.eager) {\n        const idx = this.components.length - 1;\n        setTimeout(() => {\n          this.getOrCreate(componentMetadata, idx);\n        }, 0);\n      }\n    }\n  }\n\n  private markAsyncInitializer(\n    componentMetadata: ComponentOrFactoryMetadata\n  ): void {\n    if (!isFactoryMetadata(componentMetadata)) {\n      const isAsync = Reflect.getMetadata(\n        'component:init:async',\n        componentMetadata.fn.prototype\n      ) as boolean;\n      const injects: InjectMetadata[] =\n        Reflect.getMetadata(\n          'component:injects',\n          componentMetadata.fn.prototype\n        ) || [];\n      const hasAsyncInitializers = injects.some(\n        (inject) =>\n          inject.type &&\n          (Reflect.getMetadata(\n            'component:init:async',\n            inject.type.prototype\n          ) as boolean)\n      );\n      if (!isAsync && hasAsyncInitializers) {\n        Reflect.defineMetadata(\n          'component:init:async',\n          true,\n          componentMetadata.fn.prototype\n        );\n      }\n    } else {\n      // is the factory async?...\n      const isAsync = Reflect.getMetadata(\n        'component:init:async',\n        componentMetadata.target.constructor.prototype\n      ) as boolean;\n\n      // ...then the resulting component is as well!\n      Reflect.defineMetadata(\n        'component:init:async',\n        isAsync,\n        componentMetadata.rtti.prototype\n      );\n    }\n  }\n\n  public register(component: Constructable<any>, name?: string): void {\n    const options: IComponentOptions =\n      Reflect.getMetadata('component:options', component) || {};\n    this.registerComponent({\n      fn: component,\n      options: {\n        ...options,\n        name: name || options.name,\n      },\n    });\n  }\n\n  private getComponentMetadataIndex(\n    component: Constructable<any> | undefined,\n    name?: string\n  ): number {\n    for (let i = 0, n = this.components.length; i < n; i++) {\n      if (name) {\n        if (name === this.components[i].options.name) {\n          return i;\n        }\n      } else {\n        if (\n          this.isComponentMetadataIndexFromComponentOrFactory(\n            component,\n            this.components[i]\n          )\n        ) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  private isComponentMetadataIndexFromComponentOrFactory(\n    component: Constructable<any> | undefined,\n    metadata: ComponentOrFactoryMetadata\n  ): boolean {\n    return (\n      typeof component !== 'undefined' &&\n      (isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn) === component\n    );\n  }\n\n  private throwComponentNotFoundError(\n    component?: Constructable<any>,\n    name?: string,\n    additionalInfo?: string\n  ): void {\n    if (component && !name) {\n      name = (component as any).name;\n    }\n    if (!name) {\n      name = 'unknown';\n    }\n    throw new Error(\n      `Component '${name}' not found${\n        additionalInfo ? `: ${additionalInfo}` : ''\n      }`\n    );\n  }\n\n  private getConstructorParameters(\n    metadata: ComponentOrFactoryMetadata\n  ): any[] {\n    const parameterMetadata: ParameterMetadata[] = Reflect.getMetadata(\n      'component:parameters',\n      (metadata as ComponentMetadata).fn\n    );\n    if (parameterMetadata) {\n      return parameterMetadata\n        .sort((a, b) => a.index - b.index)\n        .map((parameter) => ({\n          index: this.getComponentMetadataIndex(\n            parameter.rtti,\n            parameter.options.name\n          ),\n        }))\n        .map(({ index }) => this.getOrCreate(this.components[index], index));\n    }\n    return [];\n  }\n\n  private isSingleton(metadata: ComponentOrFactoryMetadata): boolean {\n    return (\n      typeof metadata.options.singleton === 'undefined' ||\n      metadata.options.singleton\n    );\n  }\n\n  private getOrCreateFactory(metadata: FactoryMetadata): any {\n    return this.get(metadata.target.constructor as Constructable<any>);\n  }\n\n  private hasAsyncFactoryInitializer(metadata: FactoryMetadata): boolean {\n    const factory = this.getOrCreateFactory(metadata);\n    const awaiter = this.getInitializerPromise(factory);\n    return Boolean(awaiter);\n  }\n\n  private getOrCreate<T>(metadata: ComponentOrFactoryMetadata, idx: number): T {\n    log('> getOrCreate %o', metadata);\n    let instance = this.instances[idx] as T;\n    if (!instance || !this.isSingleton(metadata)) {\n      if (isFactoryMetadata(metadata)) {\n        log(\n          'create %o from factory with %o',\n          metadata.rtti.name,\n          metadata.options\n        );\n        const factory = this.getOrCreateFactory(metadata);\n        instance = factory[metadata.property]();\n        this.instances[idx] = instance;\n      } else {\n        instance = this.createComponent(metadata, idx);\n      }\n      this.notifyOnCreate(instance);\n    }\n    log('< getOrCreate %o -> %o', metadata, instance);\n    return instance;\n  }\n\n  private addInitializerPromise(\n    instance: any,\n    value: Promise<void> | undefined\n  ): void {\n    if (value) {\n      Reflect.defineMetadata('tsdi:initialize:promise', value, instance);\n    }\n  }\n\n  private getInitializerPromise(instance: any): Promise<void> | undefined {\n    return Reflect.getMetadata('tsdi:initialize:promise', instance);\n  }\n\n  private createComponent<T>(metadata: ComponentMetadata, idx: number): T {\n    if (!this.hasEnteredScope(metadata)) {\n      this.throwComponentNotFoundError(\n        metadata.fn,\n        undefined,\n        `required scope '${metadata.options.scope}' is not enabled`\n      );\n    }\n    log('create %o with %o', metadata.fn.name, metadata.options);\n    const constructor: Constructable<T> = metadata.fn;\n    const parameters = this.getConstructorParameters(metadata);\n    const instance = new constructor(...parameters);\n    // note: This stores an incomplete instance (injects/properties/...)\n    // but it allows recursive use of injects\n    this.instances[idx] = instance;\n    this.injectIntoInstance(instance, false, metadata);\n    const init: string = Reflect.getMetadata(\n      'component:init',\n      metadata.fn.prototype\n    );\n    this.maybeLazyInitialize(instance, init, metadata);\n    return instance;\n  }\n\n  private waitForInjectInitializers(\n    metadata: ComponentMetadata\n  ): Promise<any> | undefined {\n    const injects: InjectMetadata[] = Reflect.getMetadata(\n      'component:injects',\n      metadata.fn.prototype\n    );\n    if (injects) {\n      const hasAsyncInitializers = injects.some(\n        (inject) =>\n          Reflect.getMetadata(\n            'component:init:async',\n            inject.type.prototype\n          ) as boolean\n      );\n      if (hasAsyncInitializers) {\n        return Promise.all(\n          injects.map((inject) => {\n            const [metadata, idx] = this.getInjectComponentMetadata(inject);\n            const instance = isFactoryMetadata(metadata)\n              ? this.getOrCreateFactory(metadata)\n              : this.getOrCreate(metadata, idx);\n            return this.getInitializerPromise(instance);\n          })\n        );\n      }\n    }\n    return undefined;\n  }\n\n  private hasEnteredScope(metadata: ComponentMetadata): boolean {\n    return (\n      !metadata.options.scope ||\n      Boolean(metadata.options.scope && this.scopes[metadata.options.scope])\n    );\n  }\n\n  public configureExternal<T>(args: unknown[], target: any): T {\n    const metadata: ComponentMetadata = { fn: target, options: {} };\n    const parameters = this.getConstructorParameters({\n      fn: target,\n      options: {},\n    });\n    const instance = new target(...args, ...parameters);\n    this.injectIntoInstance(instance, true, metadata);\n\n    const init: string = Reflect.getMetadata(\n      'component:init',\n      target.prototype\n    );\n    this.maybeLazyInitialize(instance, init, metadata);\n    return instance;\n  }\n\n  private maybeLazyInitialize(\n    instance: any,\n    init: string,\n    metadata: ComponentMetadata\n  ): void {\n    const awaiter = this.waitForInjectInitializers(metadata);\n    if (init) {\n      if (awaiter) {\n        this.addInitializerPromise(\n          instance,\n          awaiter\n            .then(() => instance[init].call(instance) || Promise.resolve())\n            .then(() => this.notifyOnReady(instance))\n        );\n      } else {\n        this.addInitializerPromise(\n          instance,\n          (instance[init].call(instance) || Promise.resolve()).then(() =>\n            this.notifyOnReady(instance)\n          )\n        );\n      }\n    } else if (awaiter) {\n      // tslint:disable-next-line: no-floating-promises\n      awaiter.then(() => this.notifyOnReady(instance));\n      this.addInitializerPromise(instance, awaiter);\n    } else {\n      this.notifyOnReady(instance);\n    }\n  }\n\n  private injectIntoInstance(\n    instance: any,\n    externalInstance: boolean,\n    componentMetadata: ComponentMetadata\n  ): void {\n    const injects: InjectMetadata[] = Reflect.getMetadata(\n      'component:injects',\n      componentMetadata.fn.prototype\n    );\n    if (injects) {\n      for (const inject of injects) {\n        log('injecting %s.%s', instance.constructor.name, inject.property);\n        if (\n          inject.options.name &&\n          typeof this.properties[inject.options.name] !== 'undefined'\n        ) {\n          instance[inject.property] = this.properties[inject.options.name];\n        } else {\n          this.injectDependency(\n            instance,\n            externalInstance,\n            inject,\n            componentMetadata\n          );\n        }\n      }\n    }\n  }\n\n  private injectDependency(\n    instance: any,\n    externalInstance: boolean,\n    inject: InjectMetadata,\n    componentMetadata: ComponentMetadata\n  ): void {\n    if (this.injectAutoMock(instance, inject)) {\n      return;\n    }\n\n    const isAsyncInjection = this.isAsyncInitializerDependency(inject);\n\n    const notAsyncButLazyOrDynamic = () =>\n      !isAsyncInjection && (inject.options.lazy || inject.options.dynamic);\n\n    if (notAsyncButLazyOrDynamic()) {\n      const tsdi = this;\n      Object.defineProperty(instance, inject.property, {\n        configurable: true,\n        enumerable: true,\n        get(): any {\n          log(\n            'lazy-resolve injected property %s.%s',\n            instance.constructor.name,\n            inject.property\n          );\n          const value = tsdi.getComponentDependency(\n            inject,\n            componentMetadata,\n            externalInstance\n          );\n          if (inject.options.dynamic) {\n            return value;\n          }\n          Object.defineProperty(instance, inject.property, {\n            enumerable: true,\n            value,\n          });\n          log(\n            'lazy-resolved injected property %s.%s <- %o',\n            instance.constructor.name,\n            inject.property,\n            instance[inject.property]\n          );\n          return instance[inject.property];\n        },\n      });\n    } else if (this.isAsyncFactoryInjection(inject)) {\n      this.createAsyncFactoryInjection(instance, inject);\n    } else {\n      instance[inject.property] = this.getComponentDependency(\n        inject,\n        componentMetadata,\n        externalInstance\n      );\n    }\n  }\n\n  private createAsyncFactoryInjection(\n    instance: any,\n    inject: InjectMetadata\n  ): void {\n    const [metadata] = this.getInjectComponentMetadata(inject);\n    if (!isFactoryMetadata(metadata)) {\n      throw new Error(\n        'Illegal state: async factory injection without factory metadata'\n      );\n    }\n\n    const factory = this.getOrCreateFactory(metadata);\n    const awaiter = this.getInitializerPromise(factory);\n    let ready = false;\n    if (awaiter) {\n      // tslint:disable-next-line: no-floating-promises\n      awaiter.then(() => {\n        ready = true;\n      });\n    }\n\n    Object.defineProperty(instance, inject.property, {\n      configurable: true,\n      enumerable: true,\n      get(): any {\n        if (ready) {\n          const value = factory[metadata.property]();\n          Object.defineProperty(instance, inject.property, {\n            enumerable: true,\n            value,\n          });\n          return value;\n        }\n        throw new Error('Illegal state: need to wait for factory to resolve');\n      },\n    });\n  }\n\n  private isAsyncFactoryInjection(inject: InjectMetadata): boolean {\n    const [metadata] = this.getInjectComponentMetadata(inject);\n    return isFactoryMetadata(metadata)\n      ? this.hasAsyncFactoryInitializer(metadata)\n      : false;\n  }\n\n  private isAsyncInitializerDependency(inject: InjectMetadata): boolean {\n    const [metadata] = this.getInjectComponentMetadata(inject);\n\n    const async = isFactoryMetadata(metadata)\n      ? this.hasAsyncFactoryInitializer(metadata)\n      : (Reflect.getMetadata(\n          'component:init:async',\n          metadata.fn.prototype\n        ) as boolean);\n    if (async && inject.options.dynamic) {\n      throw new Error(\n        `Injecting ${inject.type.name} into ${inject.target.constructor.name}#${inject.property} must not be dynamic since ${inject.type.name} has an async initializer`\n      );\n    }\n    return async;\n  }\n\n  private injectAutoMock(instance: any, inject: InjectMetadata): boolean {\n    if (!this.autoMock) {\n      return false;\n    }\n    const [injectMetadata] = this.getInjectComponentMetadata(inject);\n    if (injectMetadata) {\n      const constructor = isFactoryMetadata(injectMetadata)\n        ? injectMetadata.rtti\n        : injectMetadata.fn;\n      if (this.autoMock.indexOf(constructor) > -1) {\n        return false;\n      }\n      const automock = this.mock(constructor);\n      if (automock) {\n        instance[inject.property] = automock;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private createAutoMock<T>(constructor: Constructable<T>): T | undefined {\n    if (!this.autoMock || this.autoMock.indexOf(constructor) > -1) {\n      return undefined;\n    }\n    const automock = {\n      __tsdi__mock__: 'This is a TSDI automock',\n    };\n    const proto = constructor.prototype;\n    Object.getOwnPropertyNames(proto).forEach((property) => {\n      if (typeof proto[property] === 'function') {\n        (automock as any)[property] = function (...args: any[]): any {\n          return args;\n        };\n      }\n    });\n    if (automock) {\n      return automock as any;\n    }\n    return undefined;\n  }\n\n  public mock<T>(component: Constructable<T>): Mock<T> {\n    console.warn(\n      '#mock is deprecated and should not be used. Instead use #override.'\n    );\n    const idx = this.getComponentMetadataIndex(component);\n    if (!this.instances[idx]) {\n      const mock = this.createAutoMock(component);\n      if (!mock) {\n        throw new Error(`Failed to create mock from ${component.name}`);\n      }\n      this.instances[idx] = mock;\n    }\n    return this.instances[idx] as T;\n  }\n\n  private getInjectComponentMetadata(\n    inject: InjectMetadata\n  ): [ComponentOrFactoryMetadata, number] {\n    let injectIdx = this.getComponentMetadataIndex(\n      inject.type,\n      inject.options.name\n    );\n    if (injectIdx === -1) {\n      this.checkAndThrowDependencyError(inject);\n      injectIdx = this.getComponentMetadataIndex(inject.type, inject.type.name);\n    }\n    const injectMetadata = this.components[injectIdx];\n    if (!injectMetadata) {\n      if (this.parent) {\n        return this.parent.getInjectComponentMetadata(inject);\n      }\n\n      throw new Error(\n        `Failed to get inject '${\n          inject.type.name || inject.options.name\n        }' for ` + `'${inject.target.constructor.name}#${inject.property}'`\n      );\n    }\n    return [injectMetadata, injectIdx];\n  }\n\n  private getComponentDependency(\n    inject: InjectMetadata,\n    dependentMetadata: ComponentMetadata,\n    noScopeWarning: boolean\n  ): any {\n    const [metadata, injectIdx] = this.getInjectComponentMetadata(inject);\n    if (\n      !noScopeWarning &&\n      !inject.options.dynamic &&\n      !isFactoryMetadata(metadata) &&\n      metadata.options.scope &&\n      !dependentMetadata.options.scope\n    ) {\n      // tslint:disable-next-line:prefer-template\n      console.warn(\n        `Component '${metadata.fn.name}' is scoped to '${metadata.options.scope}' ` +\n          `and injected into '${dependentMetadata.fn.name}' without scope. This could easily ` +\n          `lead to stale references. Consider to add the scope '${metadata.options.scope}' to ` +\n          `'${dependentMetadata.fn.name}' as well or make the inject dynamic.`\n      );\n    }\n    return this.getOrCreate(metadata, injectIdx);\n  }\n\n  private checkAndThrowDependencyError(inject: InjectMetadata): void {\n    if (inject.type && inject.options.name) {\n      const e = new Error(\n        `Injecting undefined type on ${inject.target.constructor.name}` +\n          `#${inject.property}: Component named '${inject.options.name}' not found`\n      );\n      log(e);\n      log(\n        'Known Components: %o',\n        this.components.map((component) =>\n          isFactoryMetadata(component) ? component.rtti.name : component.fn.name\n        )\n      );\n      throw e;\n    }\n    if (!inject.type || inject.options.name) {\n      const e = new Error(\n        `Injecting undefined type on ${inject.target.constructor.name}` +\n          `#${inject.property}: Probably a cyclic dependency, switch to name based injection`\n      );\n      log(e);\n      throw e;\n    }\n  }\n\n  public get<T>(componentOrHint: string | Constructable<T>): T;\n  public get<T>(component: Constructable<T>, hint: string): T;\n  public get<T>(componentOrHint: Constructable<T> | string, hint?: string): T {\n    let component: Constructable<T> | undefined;\n    if (typeof componentOrHint === 'string') {\n      hint = componentOrHint;\n      component = undefined;\n    } else {\n      component = componentOrHint;\n    }\n    const idx = this.getComponentMetadataIndex(component, hint);\n    const metadata = this.components[idx];\n    if (!metadata) {\n      if (this.parent) {\n        return this.parent.get(componentOrHint);\n      }\n      this.throwComponentNotFoundError(component, hint);\n    }\n    return this.getOrCreate<T>(metadata, idx);\n  }\n\n  public async asyncGet<T>(component: Constructable<T>): Promise<T> {\n    return new Promise((resolve) => {\n      const removeLifecycleListener = this.addLifecycleListener({\n        onReady(comp: any): void {\n          if (comp instanceof component) {\n            removeLifecycleListener();\n            resolve(comp);\n          }\n        },\n      });\n      this.get(component);\n    });\n  }\n\n  public override(component: Constructable<any>, override: any): void {\n    const idx = this.getComponentMetadataIndex(component);\n    this.instances[idx] = override;\n    log('Override %o with %o', component, override);\n  }\n\n  public getScope(name: string): { enter(): void; leave(): void } {\n    const self = this;\n    return {\n      enter(): void {\n        self.scopes[name] = true;\n      },\n      leave(): void {\n        delete self.scopes[name];\n        self.components\n          .filter(\n            (metadata) =>\n              !isFactoryMetadata(metadata) && metadata.options.scope === name\n          )\n          .forEach((metadata) => {\n            const idx = self.getComponentMetadataIndex(\n              isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn\n            );\n            self.destroyInstance(idx, metadata);\n          });\n      },\n    };\n  }\n}\n\nexport { component, Component } from './component';\nexport { destroy, Destroy } from './destroy';\nexport { external, External } from './external';\nexport { factory, Factory } from './factory';\nexport { initialize, Initialize } from './initialize';\nexport { inject, Inject } from './inject';\nexport { configure, Configure } from './configure';\n"],"names":["test","enabled","str","indexOf","exports","module","process","env","DEBUG","window","localStorage","getItem","debug","_","log","template","args","Error","console","error","parts","arg","pos","idx","push","substring","substr","String","length","isFactoryMetadata","metadata","Boolean","rtti","findIndexOf","list","i","n","getNamedOptions","optionOrString","name","listeners","knownComponents","knownExternals","addKnownComponent","options","meta","forEach","listener","addKnownExternal","external","fn","isKnownExternal","Component","decorate","target","optionsOrString","Reflect","defineMetadata","component","Destroy","propertyKey","constructor","destroy","External","__tsdi__","configureExternal","Object","defineProperty","value","displayName","getOwnPropertyNames","filter","prop","prototype","Factory","property","toString","getMetadata","factory","Initialize","isAsync","Promise","initialize","Inject","defaultOptions","undefined","lazy","decorateProperty","type","injects","decorateParameter","parameterIndex","parameters","index","inject","Configure","orig","cacheKey","methodReturnType","propertyType","configurable","enumerable","writable","get","values","map","param","_this","call","this","TSDI","configuration","parent","registerComponent","instances","__tsdi__external__","addLifecycleListener","lifecycleListener","lifecycleListeners","keys","_this2","notifyOnCreate","parseInt","instance","getInitializerPromise","promise","then","notifyOnReady","findIndex","l","splice","onCreate","onReady","notifyOnDestroy","onDestroy","addProperty","key","properties","close","_this3","components","destroyInstance","slice","enableComponentScanner","metadataOrExternal","_this4","enableAutomock","warn","autoMock","componentMetadata","markAsyncInitializer","eager","setTimeout","_this5","getOrCreate","hasAsyncInitializers","some","register","getComponentMetadataIndex","isComponentMetadataIndexFromComponentOrFactory","throwComponentNotFoundError","additionalInfo","getConstructorParameters","parameterMetadata","sort","a","b","parameter","_this6","isSingleton","singleton","getOrCreateFactory","hasAsyncFactoryInitializer","awaiter","createComponent","addInitializerPromise","hasEnteredScope","scope","injectIntoInstance","init","maybeLazyInitialize","waitForInjectInitializers","all","_this7","getInjectComponentMetadata","scopes","resolve","_this8","externalInstance","injectDependency","injectAutoMock","isAsyncInitializerDependency","dynamic","isAsyncFactoryInjection","createAsyncFactoryInjection","getComponentDependency","tsdi","ready","async","injectMetadata","automock","mock","createAutoMock","__tsdi__mock__","proto","injectIdx","checkAndThrowDependencyError","dependentMetadata","noScopeWarning","e","componentOrHint","hint","asyncGet","removeLifecycleListener","_this10","comp","override","getScope","self","enter","leave"],"mappings":"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"}