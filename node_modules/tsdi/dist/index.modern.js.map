{"version":3,"file":"index.modern.js","sources":["../lib/debug.ts","../lib/helper.ts","../lib/global-state.ts","../lib/component.ts","../lib/destroy.ts","../lib/external.ts","../lib/factory.ts","../lib/initialize.ts","../lib/inject.ts","../lib/configure.ts","../lib/tsdi.ts"],"sourcesContent":["/* istanbul ignore next */\nconst enabled = (() => {\n  const test = (str: string | undefined | null) => {\n    return (str || '').indexOf('tsdi') !== -1 || str === '*';\n  };\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    return test(process.env.DEBUG);\n  } else if (typeof window !== 'undefined') {\n    return test(window.localStorage.getItem('DEBUG'));\n  }\n  return false;\n})();\n\n/* istanbul ignore next */\nexport const debug = (_: string) => {\n  // tslint:disable-next-line:cyclomatic-complexity\n  const log = (template: string | Error, ...args: any[]) => {\n    if (!enabled) {\n      return;\n    }\n\n    if (template instanceof Error) {\n      console.error(template);\n      return;\n    }\n\n    const parts = [];\n    let arg = 0;\n    let pos = 0;\n    let idx = template.indexOf('%', pos);\n    while (idx !== -1) {\n      parts.push(template.substring(pos, idx));\n      switch (template.substr(idx, 2)) {\n        case '%o':\n          parts.push(args[arg++]);\n          break;\n        case '%s':\n          parts.push(String(args[arg++]));\n          break;\n      }\n      pos = idx + 2;\n      idx = template.indexOf('%', pos);\n    }\n    if (pos < template.length) {\n      parts.push(template.substring(pos));\n    }\n    console.log(...parts);\n  };\n  log.enabled = enabled;\n  return log;\n};\n","import { ComponentOrFactoryMetadata, FactoryMetadata } from './tsdi';\n\nexport function isFactoryMetadata(\n  metadata: ComponentOrFactoryMetadata\n): metadata is FactoryMetadata {\n  return Boolean((metadata as FactoryMetadata).rtti);\n}\n\nexport function findIndexOf<T>(\n  list: T[],\n  test: (element: T) => boolean\n): number {\n  let idx = -1;\n  for (let i = 0, n = list.length; i < n; i++) {\n    if (test(list[i])) {\n      idx = i;\n    }\n  }\n  return idx;\n}\n\nexport function removeElement<T>(\n  list: T[],\n  test: (element: T) => boolean\n): T[] {\n  const idx = findIndexOf(list, test);\n  if (idx > -1) {\n    return [...list.slice(0, idx), ...list.slice(idx + 1)];\n  }\n  return list;\n}\n\nexport function getNamedOptions<T extends { name?: string }>(\n  optionOrString: T | string\n): T {\n  if (typeof optionOrString === 'string') {\n    const named = {\n      name: optionOrString\n    };\n    return named as T;\n  }\n  return optionOrString;\n}\n","import { findIndexOf, removeElement } from './helper';\nimport { ComponentOrFactoryMetadata } from './tsdi';\n\nexport type ComponentListener = (\n  metadataOrExternal: ComponentOrFactoryMetadata | Function\n) => void;\n\nlet listeners: ComponentListener[] = [];\nconst knownComponents: ComponentOrFactoryMetadata[] = [];\nconst knownExternals: Function[] = [];\n\nexport function addKnownComponent(metadata: ComponentOrFactoryMetadata): void {\n  if (\n    metadata.options.name &&\n    findIndexOf(\n      knownComponents,\n      (meta) => meta.options.name === metadata.options.name\n    ) > -1\n  ) {\n    throw new Error(\n      `Duplicate name '${metadata.options.name}' for known Components.`\n    );\n  }\n  knownComponents.push(metadata);\n  listeners.forEach((listener) => listener(metadata));\n}\n\nexport function addKnownExternal(external: Function): void {\n  if (!isKnownExternal(external)) {\n    knownExternals.push(external);\n    listeners.forEach((listener) => listener(external));\n  }\n}\n\nexport function isKnownExternal(external: Function): boolean {\n  return findIndexOf(knownExternals, (fn) => fn === external) !== -1;\n}\n\nexport function addListener(listener: ComponentListener): void {\n  listeners.push(listener);\n  knownComponents.forEach((metadata) => listener(metadata));\n  knownExternals.forEach((external) => listener(external));\n}\n\nexport function removeListener(listener: ComponentListener): void {\n  listeners = removeElement(listeners, (l) => l === listener);\n}\n","import { debug } from './debug';\nimport { addKnownComponent } from './global-state';\nimport { getNamedOptions } from './helper';\nimport { IComponentOptions } from './tsdi';\n\nconst log = debug('tsdi');\n\nexport function Component<TFunction extends Function>(\n  target: TFunction\n): TFunction;\nexport function Component(\n  optionsOrString?: IComponentOptions | string\n): ClassDecorator;\nexport function Component<TFunction extends Function>(\n  ...args: any[]\n): ClassDecorator | TFunction {\n  const decorate = (\n    target: TFunction,\n    optionsOrString: IComponentOptions | string = {}\n  ) => {\n    log(`@Component ${(target as any).name}`);\n    const options = getNamedOptions<IComponentOptions>(optionsOrString);\n    addKnownComponent({\n      fn: target as any,\n      options\n    });\n    Reflect.defineMetadata('component:options', options, target);\n    return target;\n  };\n\n  if (args.length === 1 && typeof args[0] === 'function') {\n    return decorate(args[0], {});\n  }\n  return function(target: TFunction): TFunction {\n    return decorate(target, args[0] || {});\n  } as ClassDecorator;\n}\nexport const component = Component;\n","import { debug } from './debug';\nconst log = debug('tsdi');\n\nexport function Destroy(target: Object, propertyKey: string): void;\nexport function Destroy(): MethodDecorator;\nexport function Destroy(...args: any[]): MethodDecorator | void {\n  const decorate = (target: Object, propertyKey: symbol | string) => {\n    log('@Destroy %s#%s', (target.constructor as any).name, propertyKey);\n    Reflect.defineMetadata('component:destroy', propertyKey, target);\n  };\n  if (args.length > 0) {\n    return decorate(args[0], args[1]);\n  }\n  return function(target: Object, propertyKey: symbol | string): void {\n    decorate(target, propertyKey);\n  };\n}\nexport const destroy = Destroy;\n","import { debug } from './debug';\nimport { addKnownExternal } from './global-state';\n\nconst log = debug('tsdi');\n\nexport function External<TFunction extends Function>(\n  target: TFunction\n): TFunction;\nexport function External(): ClassDecorator;\nexport function External<TFunction extends Function>(\n  ...args: any[]\n): ClassDecorator | TFunction {\n  const decorate = (target: TFunction) => {\n    log(`@External ${target.name}`);\n    addKnownExternal(target);\n\n    const constructor = function (this: any, ...args: any[]): any {\n      return (target as any).__tsdi__.configureExternal(args, target);\n    };\n    Object.defineProperty(constructor, 'name', {\n      value: target.name,\n    });\n    Object.defineProperty(constructor, '__tsdi__external__', {\n      value: target,\n    });\n    (constructor as any).displayName = target.name;\n    Object.getOwnPropertyNames(target)\n      .filter(\n        (prop) =>\n          prop !== 'name' &&\n          prop !== 'length' &&\n          prop !== 'caller' &&\n          prop !== 'callee' &&\n          prop !== 'arguments' &&\n          !(constructor as any)[prop]\n      )\n      .forEach((prop) => ((constructor as any)[prop] = (target as any)[prop]));\n    constructor.prototype = target.prototype;\n    return constructor as any;\n  };\n\n  if (args.length > 0) {\n    return decorate(args[0]);\n  }\n  return function (target: TFunction): TFunction {\n    return decorate(target);\n  } as ClassDecorator;\n}\nexport const external = External;\n","import { debug } from './debug';\nimport { addKnownComponent } from './global-state';\nimport { IFactoryOptions } from './tsdi';\n\nconst log = debug('tsdi');\n\nexport function Factory(target: Object, propertyKey: string): void;\nexport function Factory(options?: IFactoryOptions): MethodDecorator;\nexport function Factory(...args: any[]): MethodDecorator | void {\n  const decorate = (\n    target: Object,\n    propertyKey: string | symbol,\n    options: IFactoryOptions\n  ) => {\n    if (log.enabled) {\n      log(\n        '@Factory %s#%s({name: \"%s\"})',\n        (target.constructor as any).name,\n        propertyKey,\n        (target as any)[propertyKey].name\n      );\n    }\n    addKnownComponent({\n      target,\n      property: propertyKey.toString(),\n      options,\n      rtti: Reflect.getMetadata('design:returntype', target, propertyKey)\n    });\n  };\n\n  if (args.length > 1) {\n    return decorate(args[0], args[1], {});\n  }\n  const options = args[0] || {};\n  return function(target: Object, propertyKey: string | symbol): void {\n    decorate(target, propertyKey, options);\n  };\n}\nexport const factory = Factory;\n","import { debug } from './debug';\nconst log = debug('tsdi');\n\nexport function Initialize(target: Object, propertyKey: string): void;\nexport function Initialize(): MethodDecorator;\nexport function Initialize(...args: any[]): MethodDecorator | void {\n  const decorate = (target: Object, propertyKey: string | symbol) => {\n    log('@Initialize %s#%s', (target.constructor as any).name, propertyKey);\n    Reflect.defineMetadata('component:init', propertyKey, target);\n\n    const isAsync = Reflect.getMetadata('design:returntype', target, propertyKey) === Promise;\n    Reflect.defineMetadata('component:init:async', isAsync, target);\n  };\n  if (args.length > 0) {\n    return decorate(args[0], args[1]);\n  }\n  return function(target: Object, propertyKey: string | symbol): void {\n    decorate(target, propertyKey);\n  };\n}\nexport const initialize = Initialize;\n","import { debug } from './debug';\nimport { getNamedOptions } from './helper';\nimport {\n  Constructable,\n  IInjectOptions,\n  InjectMetadata,\n  ParameterMetadata\n} from './tsdi';\n\nconst log = debug('tsdi');\n\nexport function Inject(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex?: number\n): void;\nexport function Inject(\n  optionsOrString?: IInjectOptions | string\n): PropertyDecorator & ParameterDecorator;\nexport function Inject(\n  ...args: any[]\n): PropertyDecorator & ParameterDecorator | void {\n  const defaultOptions = (optionsOrString?: IInjectOptions | string) => {\n    const options = getNamedOptions<IInjectOptions>(optionsOrString || {});\n    if (options.lazy === undefined) {\n      options.lazy = true;\n    }\n    return options;\n  };\n  const decorateProperty = (\n    target: Object,\n    propertyKey: string | symbol,\n    options: IInjectOptions\n  ) => {\n    log(`@Inject ${(target.constructor as any).name}#${String(propertyKey)}`);\n    const type: Constructable<any> = Reflect.getMetadata(\n      'design:type',\n      target,\n      propertyKey\n    );\n    let injects: InjectMetadata[] = Reflect.getMetadata(\n      'component:injects',\n      target\n    );\n    if (!injects) {\n      injects = [];\n      Reflect.defineMetadata('component:injects', injects, target);\n    }\n    injects.push({\n      target,\n      property: propertyKey.toString(),\n      options,\n      type\n    });\n  };\n  const decorateParameter = (\n    target: Object,\n    propertyKey: string | symbol,\n    parameterIndex: number,\n    options: IInjectOptions\n  ) => {\n    log(`@Inject ${String(propertyKey)}`);\n    let parameters: ParameterMetadata[] = Reflect.getMetadata(\n      'component:parameters',\n      target\n    );\n    if (!parameters) {\n      parameters = [];\n      Reflect.defineMetadata('component:parameters', parameters, target);\n    }\n    parameters.push({\n      options,\n      index: parameterIndex,\n      rtti: Reflect.getMetadata('design:paramtypes', target)[parameterIndex]\n    });\n  };\n\n  if (args.length > 1) {\n    const options = defaultOptions({});\n    if (typeof args[2] === 'undefined') {\n      decorateProperty(args[0], args[1], options);\n    } else {\n      decorateParameter(args[0], args[1], args[2], options);\n    }\n    return;\n  }\n  return function(\n    target: Object,\n    propertyKey: string | symbol,\n    parameterIndex?: number\n  ): void {\n    const options = defaultOptions(args[0] || {});\n    if (typeof parameterIndex === 'undefined') {\n      return decorateProperty(target, propertyKey, options);\n    } else {\n      return decorateParameter(target, propertyKey, parameterIndex, options);\n    }\n  };\n}\nexport const inject = Inject;\n","import { Constructable, TSDI } from '.';\n\nexport function Configure(target: Object, property: string | symbol): any;\nexport function Configure(): any;\nexport function Configure(...args: any[]): any {\n  const decorate = (\n    target: Record<string, Function>,\n    property: string | symbol\n  ) => {\n    Reflect.defineMetadata('component:configured', true, target, property);\n\n    const orig = target[property.toString()];\n    const cacheKey = `__tsdi__${property.toString()}__`;\n\n    const methodReturnType = Reflect.getMetadata(\n      'design:returntype',\n      target,\n      property\n    );\n    const propertyType = Reflect.getMetadata('design:type', target, property);\n\n    function propertyCreator(this: {\n      __tsdi__: TSDI;\n      [cacheKey: string]: any;\n    }): any {\n      if (!methodReturnType) {\n        return this.__tsdi__.get(propertyType);\n      }\n\n      if (cacheKey in this) {\n        return this[cacheKey];\n      }\n\n      const values = Reflect.getMetadata(\n        'design:paramtypes',\n        target,\n        property\n      ).map((param: Constructable<unknown>) => this.__tsdi__.get(param));\n\n      const value = orig.call(this, ...values);\n      Object.defineProperty(this, cacheKey, {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value,\n      });\n      return value;\n    }\n\n    return {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: propertyCreator,\n    };\n  };\n  if (args.length > 0) {\n    return decorate(args[0], args[1]);\n  }\n  return (target: Object, property: string | symbol) => {\n    return decorate(target as any, property) as any;\n  };\n}\n\nexport { Configure as configure };\n","import 'reflect-metadata';\nimport { debug } from './debug';\nimport { addListener, ComponentListener, removeListener } from './global-state';\nimport { findIndexOf, isFactoryMetadata } from './helper';\n\nconst log = debug('tsdi');\n\nexport type Constructable<T> = { new (...args: any[]): T };\n\nexport type IComponentOptions = ComponentOptions;\nexport interface ComponentOptions {\n  name?: string;\n  singleton?: boolean;\n  eager?: boolean;\n  scope?: string;\n}\n\nexport type IInjectOptions = InjectOptions;\nexport interface InjectOptions {\n  name?: string;\n  lazy?: boolean;\n  dynamic?: boolean;\n}\n\nexport type IFactoryOptions = FactoryOptions;\nexport interface FactoryOptions {\n  name?: string;\n  singleton?: boolean;\n  eager?: boolean;\n}\n\n/** @internal */\nexport type InjectMetadata = {\n  target: Object;\n  property: string;\n  options: IInjectOptions;\n  type: Constructable<any>;\n};\n\n/** @internal */\nexport type ParameterMetadata = {\n  index: number;\n  rtti: Constructable<any>;\n  options: IInjectOptions;\n};\n\n/** @internal */\nexport type ComponentMetadata = {\n  fn: Constructable<any>;\n  options: IComponentOptions;\n};\n\n/** @internal */\nexport type FactoryMetadata = {\n  target: Object;\n  property: string;\n  options: IFactoryOptions;\n  rtti: Constructable<any>;\n};\n\n/** @internal */\nexport type ComponentOrFactoryMetadata = ComponentMetadata | FactoryMetadata;\n\nexport type Mock<T> = { -readonly [P in keyof T]: T[P] };\n\nexport interface LifecycleListener {\n  onCreate?(component: any): void;\n  onReady?(component: any): void;\n  onDestroy?(component: any): void;\n}\n\nexport class TSDI {\n  private autoMock: any[] | undefined = undefined;\n\n  private readonly components: ComponentOrFactoryMetadata[] = [];\n\n  private instances: { [idx: number]: Object } = {};\n\n  private listener: ComponentListener | undefined;\n\n  private readonly properties: { [key: string]: any } = {};\n\n  private readonly lifecycleListeners: LifecycleListener[] = [];\n\n  private readonly scopes: { [name: string]: boolean } = {};\n\n  private readonly parent: TSDI | undefined;\n\n  constructor(configuration?: Object, parent?: TSDI) {\n    this.registerComponent({\n      fn: TSDI,\n      options: {},\n    });\n    this.instances[0] = this;\n\n    if (configuration) {\n      this.registerComponent({\n        fn: configuration.constructor as Constructable<unknown>,\n        options: {},\n      });\n      this.instances[1] = configuration;\n      Object.defineProperty(configuration, '__tsdi__', {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value: this,\n      });\n\n      Object.getOwnPropertyNames(configuration.constructor.prototype)\n        .filter((name) =>\n          Reflect.getMetadata(\n            'component:configured',\n            configuration.constructor.prototype,\n            name\n          )\n        )\n        .forEach((property) => {\n          const rtti = Reflect.getMetadata(\n            'design:returntype',\n            configuration,\n            property\n          );\n          if (rtti) {\n            // method\n            this.registerComponent({\n              target: configuration,\n              property,\n              options: {},\n              rtti,\n            });\n          } else {\n            const fn = Reflect.getMetadata(\n              'design:type',\n              configuration,\n              property\n            );\n            if (fn.__tsdi__external__) {\n              // external component\n              fn.__tsdi__external__.__tsdi__ = this;\n            } else {\n              // property component\n              this.registerComponent({\n                fn,\n                options: {},\n              });\n            }\n          }\n        });\n    }\n    this.parent = parent;\n  }\n\n  public addLifecycleListener(\n    lifecycleListener: LifecycleListener\n  ): () => void {\n    this.lifecycleListeners.push(lifecycleListener);\n    Object.keys(this.instances).forEach((idx) =>\n      this.notifyOnCreate(this.instances[parseInt(idx, 10)])\n    );\n\n    Object.values(this.instances)\n      .map(\n        (instance) => [instance, this.getInitializerPromise(instance)] as const\n      )\n      .forEach(([instance, promise]) =>\n        promise?.then(() => this.notifyOnReady(instance))\n      );\n\n    return () => {\n      const idx = this.lifecycleListeners.findIndex(\n        (l) => l === lifecycleListener\n      );\n      this.lifecycleListeners.splice(idx, 1);\n    };\n  }\n\n  private notifyOnCreate(component: any): void {\n    this.lifecycleListeners.forEach((l) => l.onCreate?.(component));\n  }\n\n  private notifyOnReady(component: any): void {\n    this.lifecycleListeners.forEach((l) => l.onReady?.(component));\n  }\n\n  private notifyOnDestroy(component: any): void {\n    this.lifecycleListeners.forEach((l) => l.onDestroy?.(component));\n  }\n\n  public addProperty(key: string, value: any): void {\n    this.properties[key] = value;\n  }\n\n  public close(): void {\n    Object.keys(this.instances).forEach((key) => {\n      const idx = parseInt(key, 10);\n      const metadata = this.components[idx];\n      if (!isFactoryMetadata(metadata)) {\n        this.destroyInstance(idx, metadata);\n      }\n    });\n    this.instances = [];\n\n    if (this.listener) {\n      removeListener(this.listener);\n      this.listener = undefined;\n    }\n  }\n\n  private destroyInstance(\n    idx: number,\n    metadata: ComponentOrFactoryMetadata\n  ): void {\n    const instance = this.instances[idx];\n    if (instance) {\n      this.notifyOnDestroy(instance);\n\n      const destroy = Reflect.getMetadata(\n        'component:destroy',\n        isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn.prototype\n      );\n      if (destroy && (instance as any)[destroy]) {\n        (instance as any)[destroy].call(instance);\n      }\n      (this.instances[idx] as any) = undefined;\n    }\n  }\n\n  public enableComponentScanner(): void {\n    if (!this.listener) {\n      this.listener = (\n        metadataOrExternal: Parameters<ComponentListener>[0]\n      ) => {\n        if (typeof metadataOrExternal === 'function') {\n          (metadataOrExternal as any).__tsdi__ = this;\n        } else {\n          this.registerComponent(metadataOrExternal);\n        }\n      };\n      if (this.listener) {\n        addListener(this.listener);\n      }\n    }\n  }\n\n  public enableAutomock(...allowedDependencies: any[]): void {\n    console.warn(\n      '#enableAutomock is deprecated and should not be used. Instead use #override.'\n    );\n    this.autoMock = allowedDependencies;\n  }\n\n  private registerComponent(\n    componentMetadata: ComponentOrFactoryMetadata\n  ): void {\n    if (this.components.indexOf(componentMetadata) === -1) {\n      if (\n        componentMetadata.options.name &&\n        findIndexOf(\n          this.components,\n          (meta) => meta.options.name === componentMetadata.options.name\n        ) > -1\n      ) {\n        console.warn(\n          `Component with name '${componentMetadata.options.name}' already registered.`\n        );\n      }\n\n      this.markAsyncInitializer(componentMetadata);\n\n      log(\n        'registerComponent %o',\n        isFactoryMetadata(componentMetadata)\n          ? (componentMetadata.rtti as any).name\n          : (componentMetadata.fn as any).name\n      );\n      this.components.push(componentMetadata);\n      if (componentMetadata.options.eager) {\n        const idx = this.components.length - 1;\n        setTimeout(() => {\n          this.getOrCreate(componentMetadata, idx);\n        }, 0);\n      }\n    }\n  }\n\n  private markAsyncInitializer(\n    componentMetadata: ComponentOrFactoryMetadata\n  ): void {\n    if (!isFactoryMetadata(componentMetadata)) {\n      const isAsync = Reflect.getMetadata(\n        'component:init:async',\n        componentMetadata.fn.prototype\n      ) as boolean;\n      const injects: InjectMetadata[] =\n        Reflect.getMetadata(\n          'component:injects',\n          componentMetadata.fn.prototype\n        ) || [];\n      const hasAsyncInitializers = injects.some(\n        (inject) =>\n          inject.type &&\n          (Reflect.getMetadata(\n            'component:init:async',\n            inject.type.prototype\n          ) as boolean)\n      );\n      if (!isAsync && hasAsyncInitializers) {\n        Reflect.defineMetadata(\n          'component:init:async',\n          true,\n          componentMetadata.fn.prototype\n        );\n      }\n    } else {\n      // is the factory async?...\n      const isAsync = Reflect.getMetadata(\n        'component:init:async',\n        componentMetadata.target.constructor.prototype\n      ) as boolean;\n\n      // ...then the resulting component is as well!\n      Reflect.defineMetadata(\n        'component:init:async',\n        isAsync,\n        componentMetadata.rtti.prototype\n      );\n    }\n  }\n\n  public register(component: Constructable<any>, name?: string): void {\n    const options: IComponentOptions =\n      Reflect.getMetadata('component:options', component) || {};\n    this.registerComponent({\n      fn: component,\n      options: {\n        ...options,\n        name: name || options.name,\n      },\n    });\n  }\n\n  private getComponentMetadataIndex(\n    component: Constructable<any> | undefined,\n    name?: string\n  ): number {\n    for (let i = 0, n = this.components.length; i < n; i++) {\n      if (name) {\n        if (name === this.components[i].options.name) {\n          return i;\n        }\n      } else {\n        if (\n          this.isComponentMetadataIndexFromComponentOrFactory(\n            component,\n            this.components[i]\n          )\n        ) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  private isComponentMetadataIndexFromComponentOrFactory(\n    component: Constructable<any> | undefined,\n    metadata: ComponentOrFactoryMetadata\n  ): boolean {\n    return (\n      typeof component !== 'undefined' &&\n      (isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn) === component\n    );\n  }\n\n  private throwComponentNotFoundError(\n    component?: Constructable<any>,\n    name?: string,\n    additionalInfo?: string\n  ): void {\n    if (component && !name) {\n      name = (component as any).name;\n    }\n    if (!name) {\n      name = 'unknown';\n    }\n    throw new Error(\n      `Component '${name}' not found${\n        additionalInfo ? `: ${additionalInfo}` : ''\n      }`\n    );\n  }\n\n  private getConstructorParameters(\n    metadata: ComponentOrFactoryMetadata\n  ): any[] {\n    const parameterMetadata: ParameterMetadata[] = Reflect.getMetadata(\n      'component:parameters',\n      (metadata as ComponentMetadata).fn\n    );\n    if (parameterMetadata) {\n      return parameterMetadata\n        .sort((a, b) => a.index - b.index)\n        .map((parameter) => ({\n          index: this.getComponentMetadataIndex(\n            parameter.rtti,\n            parameter.options.name\n          ),\n        }))\n        .map(({ index }) => this.getOrCreate(this.components[index], index));\n    }\n    return [];\n  }\n\n  private isSingleton(metadata: ComponentOrFactoryMetadata): boolean {\n    return (\n      typeof metadata.options.singleton === 'undefined' ||\n      metadata.options.singleton\n    );\n  }\n\n  private getOrCreateFactory(metadata: FactoryMetadata): any {\n    return this.get(metadata.target.constructor as Constructable<any>);\n  }\n\n  private hasAsyncFactoryInitializer(metadata: FactoryMetadata): boolean {\n    const factory = this.getOrCreateFactory(metadata);\n    const awaiter = this.getInitializerPromise(factory);\n    return Boolean(awaiter);\n  }\n\n  private getOrCreate<T>(metadata: ComponentOrFactoryMetadata, idx: number): T {\n    log('> getOrCreate %o', metadata);\n    let instance = this.instances[idx] as T;\n    if (!instance || !this.isSingleton(metadata)) {\n      if (isFactoryMetadata(metadata)) {\n        log(\n          'create %o from factory with %o',\n          metadata.rtti.name,\n          metadata.options\n        );\n        const factory = this.getOrCreateFactory(metadata);\n        instance = factory[metadata.property]();\n        this.instances[idx] = instance;\n      } else {\n        instance = this.createComponent(metadata, idx);\n      }\n      this.notifyOnCreate(instance);\n    }\n    log('< getOrCreate %o -> %o', metadata, instance);\n    return instance;\n  }\n\n  private addInitializerPromise(\n    instance: any,\n    value: Promise<void> | undefined\n  ): void {\n    if (value) {\n      Reflect.defineMetadata('tsdi:initialize:promise', value, instance);\n    }\n  }\n\n  private getInitializerPromise(instance: any): Promise<void> | undefined {\n    return Reflect.getMetadata('tsdi:initialize:promise', instance);\n  }\n\n  private createComponent<T>(metadata: ComponentMetadata, idx: number): T {\n    if (!this.hasEnteredScope(metadata)) {\n      this.throwComponentNotFoundError(\n        metadata.fn,\n        undefined,\n        `required scope '${metadata.options.scope}' is not enabled`\n      );\n    }\n    log('create %o with %o', metadata.fn.name, metadata.options);\n    const constructor: Constructable<T> = metadata.fn;\n    const parameters = this.getConstructorParameters(metadata);\n    const instance = new constructor(...parameters);\n    // note: This stores an incomplete instance (injects/properties/...)\n    // but it allows recursive use of injects\n    this.instances[idx] = instance;\n    this.injectIntoInstance(instance, false, metadata);\n    const init: string = Reflect.getMetadata(\n      'component:init',\n      metadata.fn.prototype\n    );\n    this.maybeLazyInitialize(instance, init, metadata);\n    return instance;\n  }\n\n  private waitForInjectInitializers(\n    metadata: ComponentMetadata\n  ): Promise<any> | undefined {\n    const injects: InjectMetadata[] = Reflect.getMetadata(\n      'component:injects',\n      metadata.fn.prototype\n    );\n    if (injects) {\n      const hasAsyncInitializers = injects.some(\n        (inject) =>\n          Reflect.getMetadata(\n            'component:init:async',\n            inject.type.prototype\n          ) as boolean\n      );\n      if (hasAsyncInitializers) {\n        return Promise.all(\n          injects.map((inject) => {\n            const [metadata, idx] = this.getInjectComponentMetadata(inject);\n            const instance = isFactoryMetadata(metadata)\n              ? this.getOrCreateFactory(metadata)\n              : this.getOrCreate(metadata, idx);\n            return this.getInitializerPromise(instance);\n          })\n        );\n      }\n    }\n    return undefined;\n  }\n\n  private hasEnteredScope(metadata: ComponentMetadata): boolean {\n    return (\n      !metadata.options.scope ||\n      Boolean(metadata.options.scope && this.scopes[metadata.options.scope])\n    );\n  }\n\n  public configureExternal<T>(args: unknown[], target: any): T {\n    const metadata: ComponentMetadata = { fn: target, options: {} };\n    const parameters = this.getConstructorParameters({\n      fn: target,\n      options: {},\n    });\n    const instance = new target(...args, ...parameters);\n    this.injectIntoInstance(instance, true, metadata);\n\n    const init: string = Reflect.getMetadata(\n      'component:init',\n      target.prototype\n    );\n    this.maybeLazyInitialize(instance, init, metadata);\n    return instance;\n  }\n\n  private maybeLazyInitialize(\n    instance: any,\n    init: string,\n    metadata: ComponentMetadata\n  ): void {\n    const awaiter = this.waitForInjectInitializers(metadata);\n    if (init) {\n      if (awaiter) {\n        this.addInitializerPromise(\n          instance,\n          awaiter\n            .then(() => instance[init].call(instance) || Promise.resolve())\n            .then(() => this.notifyOnReady(instance))\n        );\n      } else {\n        this.addInitializerPromise(\n          instance,\n          (instance[init].call(instance) || Promise.resolve()).then(() =>\n            this.notifyOnReady(instance)\n          )\n        );\n      }\n    } else if (awaiter) {\n      // tslint:disable-next-line: no-floating-promises\n      awaiter.then(() => this.notifyOnReady(instance));\n      this.addInitializerPromise(instance, awaiter);\n    } else {\n      this.notifyOnReady(instance);\n    }\n  }\n\n  private injectIntoInstance(\n    instance: any,\n    externalInstance: boolean,\n    componentMetadata: ComponentMetadata\n  ): void {\n    const injects: InjectMetadata[] = Reflect.getMetadata(\n      'component:injects',\n      componentMetadata.fn.prototype\n    );\n    if (injects) {\n      for (const inject of injects) {\n        log('injecting %s.%s', instance.constructor.name, inject.property);\n        if (\n          inject.options.name &&\n          typeof this.properties[inject.options.name] !== 'undefined'\n        ) {\n          instance[inject.property] = this.properties[inject.options.name];\n        } else {\n          this.injectDependency(\n            instance,\n            externalInstance,\n            inject,\n            componentMetadata\n          );\n        }\n      }\n    }\n  }\n\n  private injectDependency(\n    instance: any,\n    externalInstance: boolean,\n    inject: InjectMetadata,\n    componentMetadata: ComponentMetadata\n  ): void {\n    if (this.injectAutoMock(instance, inject)) {\n      return;\n    }\n\n    const isAsyncInjection = this.isAsyncInitializerDependency(inject);\n\n    const notAsyncButLazyOrDynamic = () =>\n      !isAsyncInjection && (inject.options.lazy || inject.options.dynamic);\n\n    if (notAsyncButLazyOrDynamic()) {\n      const tsdi = this;\n      Object.defineProperty(instance, inject.property, {\n        configurable: true,\n        enumerable: true,\n        get(): any {\n          log(\n            'lazy-resolve injected property %s.%s',\n            instance.constructor.name,\n            inject.property\n          );\n          const value = tsdi.getComponentDependency(\n            inject,\n            componentMetadata,\n            externalInstance\n          );\n          if (inject.options.dynamic) {\n            return value;\n          }\n          Object.defineProperty(instance, inject.property, {\n            enumerable: true,\n            value,\n          });\n          log(\n            'lazy-resolved injected property %s.%s <- %o',\n            instance.constructor.name,\n            inject.property,\n            instance[inject.property]\n          );\n          return instance[inject.property];\n        },\n      });\n    } else if (this.isAsyncFactoryInjection(inject)) {\n      this.createAsyncFactoryInjection(instance, inject);\n    } else {\n      instance[inject.property] = this.getComponentDependency(\n        inject,\n        componentMetadata,\n        externalInstance\n      );\n    }\n  }\n\n  private createAsyncFactoryInjection(\n    instance: any,\n    inject: InjectMetadata\n  ): void {\n    const [metadata] = this.getInjectComponentMetadata(inject);\n    if (!isFactoryMetadata(metadata)) {\n      throw new Error(\n        'Illegal state: async factory injection without factory metadata'\n      );\n    }\n\n    const factory = this.getOrCreateFactory(metadata);\n    const awaiter = this.getInitializerPromise(factory);\n    let ready = false;\n    if (awaiter) {\n      // tslint:disable-next-line: no-floating-promises\n      awaiter.then(() => {\n        ready = true;\n      });\n    }\n\n    Object.defineProperty(instance, inject.property, {\n      configurable: true,\n      enumerable: true,\n      get(): any {\n        if (ready) {\n          const value = factory[metadata.property]();\n          Object.defineProperty(instance, inject.property, {\n            enumerable: true,\n            value,\n          });\n          return value;\n        }\n        throw new Error('Illegal state: need to wait for factory to resolve');\n      },\n    });\n  }\n\n  private isAsyncFactoryInjection(inject: InjectMetadata): boolean {\n    const [metadata] = this.getInjectComponentMetadata(inject);\n    return isFactoryMetadata(metadata)\n      ? this.hasAsyncFactoryInitializer(metadata)\n      : false;\n  }\n\n  private isAsyncInitializerDependency(inject: InjectMetadata): boolean {\n    const [metadata] = this.getInjectComponentMetadata(inject);\n\n    const async = isFactoryMetadata(metadata)\n      ? this.hasAsyncFactoryInitializer(metadata)\n      : (Reflect.getMetadata(\n          'component:init:async',\n          metadata.fn.prototype\n        ) as boolean);\n    if (async && inject.options.dynamic) {\n      throw new Error(\n        `Injecting ${inject.type.name} into ${inject.target.constructor.name}#${inject.property} must not be dynamic since ${inject.type.name} has an async initializer`\n      );\n    }\n    return async;\n  }\n\n  private injectAutoMock(instance: any, inject: InjectMetadata): boolean {\n    if (!this.autoMock) {\n      return false;\n    }\n    const [injectMetadata] = this.getInjectComponentMetadata(inject);\n    if (injectMetadata) {\n      const constructor = isFactoryMetadata(injectMetadata)\n        ? injectMetadata.rtti\n        : injectMetadata.fn;\n      if (this.autoMock.indexOf(constructor) > -1) {\n        return false;\n      }\n      const automock = this.mock(constructor);\n      if (automock) {\n        instance[inject.property] = automock;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private createAutoMock<T>(constructor: Constructable<T>): T | undefined {\n    if (!this.autoMock || this.autoMock.indexOf(constructor) > -1) {\n      return undefined;\n    }\n    const automock = {\n      __tsdi__mock__: 'This is a TSDI automock',\n    };\n    const proto = constructor.prototype;\n    Object.getOwnPropertyNames(proto).forEach((property) => {\n      if (typeof proto[property] === 'function') {\n        (automock as any)[property] = function (...args: any[]): any {\n          return args;\n        };\n      }\n    });\n    if (automock) {\n      return automock as any;\n    }\n    return undefined;\n  }\n\n  public mock<T>(component: Constructable<T>): Mock<T> {\n    console.warn(\n      '#mock is deprecated and should not be used. Instead use #override.'\n    );\n    const idx = this.getComponentMetadataIndex(component);\n    if (!this.instances[idx]) {\n      const mock = this.createAutoMock(component);\n      if (!mock) {\n        throw new Error(`Failed to create mock from ${component.name}`);\n      }\n      this.instances[idx] = mock;\n    }\n    return this.instances[idx] as T;\n  }\n\n  private getInjectComponentMetadata(\n    inject: InjectMetadata\n  ): [ComponentOrFactoryMetadata, number] {\n    let injectIdx = this.getComponentMetadataIndex(\n      inject.type,\n      inject.options.name\n    );\n    if (injectIdx === -1) {\n      this.checkAndThrowDependencyError(inject);\n      injectIdx = this.getComponentMetadataIndex(inject.type, inject.type.name);\n    }\n    const injectMetadata = this.components[injectIdx];\n    if (!injectMetadata) {\n      if (this.parent) {\n        return this.parent.getInjectComponentMetadata(inject);\n      }\n\n      throw new Error(\n        `Failed to get inject '${\n          inject.type.name || inject.options.name\n        }' for ` + `'${inject.target.constructor.name}#${inject.property}'`\n      );\n    }\n    return [injectMetadata, injectIdx];\n  }\n\n  private getComponentDependency(\n    inject: InjectMetadata,\n    dependentMetadata: ComponentMetadata,\n    noScopeWarning: boolean\n  ): any {\n    const [metadata, injectIdx] = this.getInjectComponentMetadata(inject);\n    if (\n      !noScopeWarning &&\n      !inject.options.dynamic &&\n      !isFactoryMetadata(metadata) &&\n      metadata.options.scope &&\n      !dependentMetadata.options.scope\n    ) {\n      // tslint:disable-next-line:prefer-template\n      console.warn(\n        `Component '${metadata.fn.name}' is scoped to '${metadata.options.scope}' ` +\n          `and injected into '${dependentMetadata.fn.name}' without scope. This could easily ` +\n          `lead to stale references. Consider to add the scope '${metadata.options.scope}' to ` +\n          `'${dependentMetadata.fn.name}' as well or make the inject dynamic.`\n      );\n    }\n    return this.getOrCreate(metadata, injectIdx);\n  }\n\n  private checkAndThrowDependencyError(inject: InjectMetadata): void {\n    if (inject.type && inject.options.name) {\n      const e = new Error(\n        `Injecting undefined type on ${inject.target.constructor.name}` +\n          `#${inject.property}: Component named '${inject.options.name}' not found`\n      );\n      log(e);\n      log(\n        'Known Components: %o',\n        this.components.map((component) =>\n          isFactoryMetadata(component) ? component.rtti.name : component.fn.name\n        )\n      );\n      throw e;\n    }\n    if (!inject.type || inject.options.name) {\n      const e = new Error(\n        `Injecting undefined type on ${inject.target.constructor.name}` +\n          `#${inject.property}: Probably a cyclic dependency, switch to name based injection`\n      );\n      log(e);\n      throw e;\n    }\n  }\n\n  public get<T>(componentOrHint: string | Constructable<T>): T;\n  public get<T>(component: Constructable<T>, hint: string): T;\n  public get<T>(componentOrHint: Constructable<T> | string, hint?: string): T {\n    let component: Constructable<T> | undefined;\n    if (typeof componentOrHint === 'string') {\n      hint = componentOrHint;\n      component = undefined;\n    } else {\n      component = componentOrHint;\n    }\n    const idx = this.getComponentMetadataIndex(component, hint);\n    const metadata = this.components[idx];\n    if (!metadata) {\n      if (this.parent) {\n        return this.parent.get(componentOrHint);\n      }\n      this.throwComponentNotFoundError(component, hint);\n    }\n    return this.getOrCreate<T>(metadata, idx);\n  }\n\n  public async asyncGet<T>(component: Constructable<T>): Promise<T> {\n    return new Promise((resolve) => {\n      const removeLifecycleListener = this.addLifecycleListener({\n        onReady(comp: any): void {\n          if (comp instanceof component) {\n            removeLifecycleListener();\n            resolve(comp);\n          }\n        },\n      });\n      this.get(component);\n    });\n  }\n\n  public override(component: Constructable<any>, override: any): void {\n    const idx = this.getComponentMetadataIndex(component);\n    this.instances[idx] = override;\n    log('Override %o with %o', component, override);\n  }\n\n  public getScope(name: string): { enter(): void; leave(): void } {\n    const self = this;\n    return {\n      enter(): void {\n        self.scopes[name] = true;\n      },\n      leave(): void {\n        delete self.scopes[name];\n        self.components\n          .filter(\n            (metadata) =>\n              !isFactoryMetadata(metadata) && metadata.options.scope === name\n          )\n          .forEach((metadata) => {\n            const idx = self.getComponentMetadataIndex(\n              isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn\n            );\n            self.destroyInstance(idx, metadata);\n          });\n      },\n    };\n  }\n}\n\nexport { component, Component } from './component';\nexport { destroy, Destroy } from './destroy';\nexport { external, External } from './external';\nexport { factory, Factory } from './factory';\nexport { initialize, Initialize } from './initialize';\nexport { inject, Inject } from './inject';\nexport { configure, Configure } from './configure';\n"],"names":["enabled","test","str","indexOf","exports","module","process","env","DEBUG","window","localStorage","getItem","debug","_","log","template","args","Error","console","error","parts","arg","pos","idx","push","substring","substr","String","length","isFactoryMetadata","metadata","Boolean","rtti","findIndexOf","list","i","n","getNamedOptions","optionOrString","name","listeners","knownComponents","knownExternals","addKnownComponent","options","meta","forEach","listener","Component","decorate","target","optionsOrString","fn","Reflect","defineMetadata","component","Destroy","propertyKey","constructor","destroy","External","external","isKnownExternal","addKnownExternal","__tsdi__","configureExternal","Object","defineProperty","value","displayName","getOwnPropertyNames","filter","prop","prototype","Factory","property","toString","getMetadata","factory","Initialize","isAsync","Promise","initialize","Inject","defaultOptions","undefined","lazy","decorateProperty","type","injects","decorateParameter","parameterIndex","parameters","index","inject","Configure","orig","cacheKey","methodReturnType","propertyType","configurable","enumerable","writable","get","values","map","param","this","call","TSDI","configuration","parent","registerComponent","instances","__tsdi__external__","addLifecycleListener","lifecycleListener","lifecycleListeners","keys","notifyOnCreate","parseInt","instance","getInitializerPromise","promise","then","notifyOnReady","findIndex","l","splice","onCreate","onReady","notifyOnDestroy","onDestroy","addProperty","key","properties","close","components","destroyInstance","slice","removeElement","enableComponentScanner","metadataOrExternal","enableAutomock","allowedDependencies","warn","autoMock","componentMetadata","markAsyncInitializer","eager","setTimeout","getOrCreate","hasAsyncInitializers","some","register","getComponentMetadataIndex","isComponentMetadataIndexFromComponentOrFactory","throwComponentNotFoundError","additionalInfo","getConstructorParameters","parameterMetadata","sort","a","b","parameter","isSingleton","singleton","getOrCreateFactory","hasAsyncFactoryInitializer","awaiter","createComponent","addInitializerPromise","hasEnteredScope","scope","injectIntoInstance","init","maybeLazyInitialize","waitForInjectInitializers","all","getInjectComponentMetadata","scopes","resolve","externalInstance","injectDependency","injectAutoMock","isAsyncInitializerDependency","dynamic","isAsyncFactoryInjection","createAsyncFactoryInjection","getComponentDependency","tsdi","ready","async","injectMetadata","automock","mock","createAutoMock","__tsdi__mock__","proto","injectIdx","checkAndThrowDependencyError","dependentMetadata","noScopeWarning","e","componentOrHint","hint","[object Object]","removeLifecycleListener","comp","override","getScope","self","enter","leave"],"mappings":"wOACA,MAAMA,EAAU,MACd,MAAMC,EAAQC,IAC4B,KAAhCA,GAAO,IAAIC,QAAQ,SAA0B,MAARD,EAE/C,MAAuB,iBAAZE,SAA0C,oBAAXC,OACjCJ,EAAKK,QAAQC,IAAIC,OACG,oBAAXC,QACTR,EAAKQ,OAAOC,aAAaC,QAAQ,WAP5B,GAaHC,EAASC,IAEpB,MAAMC,EAAM,CAACC,KAA6BC,KACxC,IAAKhB,EACH,OAGF,GAAIe,aAAoBE,MAEtB,YADAC,QAAQC,MAAMJ,GAIhB,MAAMK,EAAQ,GACd,IAAIC,EAAM,EACNC,EAAM,EACNC,EAAMR,EAASZ,QAAQ,IAAKmB,GAChC,MAAgB,IAATC,GAAY,CAEjB,OADAH,EAAMI,KAAKT,EAASU,UAAUH,EAAKC,IAC3BR,EAASW,OAAOH,EAAK,IAC3B,IAAK,KACHH,EAAMI,KAAKR,EAAKK,MAChB,MACF,IAAK,KACHD,EAAMI,KAAKG,OAAOX,EAAKK,OAG3BC,EAAMC,EAAM,EACZA,EAAMR,EAASZ,QAAQ,IAAKmB,GAE1BA,EAAMP,EAASa,QACjBR,EAAMI,KAAKT,EAASU,UAAUH,IAEhCJ,QAAQJ,OAAOM,IAGjB,OADAN,EAAId,QAAUA,EACPc,YC/COe,EACdC,GAEA,OAAOC,QAASD,EAA6BE,MAG/C,SAAgBC,EACdC,EACAjC,GAEA,IAAIsB,GAAO,EACX,IAAK,IAAIY,EAAI,EAAGC,EAAIF,EAAKN,OAAQO,EAAIC,EAAGD,IAClClC,EAAKiC,EAAKC,MACZZ,EAAMY,GAGV,OAAOZ,EAcT,SAAgBc,EACdC,GAEA,MAA8B,iBAAnBA,EACK,CACZC,KAAMD,GAIHA,MClCLE,EAAiC,GACrC,MAAMC,EAAgD,GAChDC,EAA6B,YAEnBC,EAAkBb,GAChC,GACEA,EAASc,QAAQL,MACjBN,EACEQ,EACCI,GAASA,EAAKD,QAAQL,OAAST,EAASc,QAAQL,OAC9C,EAEL,UAAUtB,yBACWa,EAASc,QAAQL,+BAGxCE,EAAgBjB,KAAKM,GACrBU,EAAUM,QAASC,GAAaA,EAASjB,UCnBrChB,EAAMF,aAQIoC,KACXhC,GAEH,MAAMiC,EAAW,CACfC,EACAC,EAA8C,MAE9CrC,gBAAmBoC,EAAeX,MAClC,MAAMK,EAAUP,EAAmCc,GAMnD,OALAR,EAAkB,CAChBS,GAAIF,EACJN,QAAAA,IAEFS,QAAQC,eAAe,oBAAqBV,EAASM,GAC9CA,GAGT,OAAoB,IAAhBlC,EAAKY,QAAmC,mBAAZZ,EAAK,GAC5BiC,EAASjC,EAAK,GAAI,aAEXkC,GACd,OAAOD,EAASC,EAAQlC,EAAK,IAAM,KAGvC,MAAauC,EAAYP,ECpCnBlC,EAAMF,IAIZ,SAAgB4C,KAAWxC,GACzB,MAAMiC,EAAW,CAACC,EAAgBO,KAChC3C,EAAI,iBAAmBoC,EAAOQ,YAAoBnB,KAAMkB,GACxDJ,QAAQC,eAAe,oBAAqBG,EAAaP,IAE3D,OAAIlC,EAAKY,OAAS,EACTqB,EAASjC,EAAK,GAAIA,EAAK,aAEhBkC,EAAgBO,GAC9BR,EAASC,EAAQO,IAGrB,MAAaE,EAAUH,ECdjB1C,EAAMF,IAMZ,SAAgBgD,KACX5C,GAEH,MAAMiC,EAAYC,IAChBpC,eAAiBoC,EAAOX,MHc5B,SAAiCsB,IAOjC,SAAgCA,GAC9B,OAAiE,IAA1D5B,EAAYS,EAAiBU,GAAOA,IAAOS,IAP7CC,CAAgBD,KACnBnB,EAAelB,KAAKqC,GACpBrB,EAAUM,QAASC,GAAaA,EAASc,KGhBzCE,CAAiBb,GAEjB,MAAMQ,EAAc,YAAwB1C,GAC1C,OAAQkC,EAAec,SAASC,kBAAkBjD,EAAMkC,IAqB1D,OAnBAgB,OAAOC,eAAeT,EAAa,OAAQ,CACzCU,MAAOlB,EAAOX,OAEhB2B,OAAOC,eAAeT,EAAa,qBAAsB,CACvDU,MAAOlB,IAERQ,EAAoBW,YAAcnB,EAAOX,KAC1C2B,OAAOI,oBAAoBpB,GACxBqB,OACEC,GACU,SAATA,GACS,WAATA,GACS,WAATA,GACS,WAATA,GACS,cAATA,IACEd,EAAoBc,IAEzB1B,QAAS0B,GAAWd,EAAoBc,GAAStB,EAAesB,IACnEd,EAAYe,UAAYvB,EAAOuB,UACxBf,GAGT,OAAI1C,EAAKY,OAAS,EACTqB,EAASjC,EAAK,aAENkC,GACf,OAAOD,EAASC,IAGpB,MAAaW,EAAWD,EC5ClB9C,EAAMF,aAII8D,KAAW1D,GACzB,MAAMiC,EAAW,CACfC,EACAO,EACAb,KAEI9B,EAAId,SACNc,EACE,+BACCoC,EAAOQ,YAAoBnB,KAC5BkB,EACCP,EAAeO,GAAalB,MAGjCI,EAAkB,CAChBO,OAAAA,EACAyB,SAAUlB,EAAYmB,WACtBhC,QAAAA,EACAZ,KAAMqB,QAAQwB,YAAY,oBAAqB3B,EAAQO,MAI3D,GAAIzC,EAAKY,OAAS,EAChB,OAAOqB,EAASjC,EAAK,GAAIA,EAAK,GAAI,IAEpC,MAAM4B,EAAU5B,EAAK,IAAM,GAC3B,gBAAgBkC,EAAgBO,GAC9BR,EAASC,EAAQO,EAAab,IAGrBkC,MAAAA,EAAUJ,ECrCjB5D,EAAMF,IAIZ,SAAgBmE,KAAc/D,GAC5B,MAAMiC,EAAW,CAACC,EAAgBO,KAChC3C,EAAI,oBAAsBoC,EAAOQ,YAAoBnB,KAAMkB,GAC3DJ,QAAQC,eAAe,iBAAkBG,EAAaP,GAEtD,MAAM8B,EAAU3B,QAAQwB,YAAY,oBAAqB3B,EAAQO,KAAiBwB,QAClF5B,QAAQC,eAAe,uBAAwB0B,EAAS9B,IAE1D,OAAIlC,EAAKY,OAAS,EACTqB,EAASjC,EAAK,GAAIA,EAAK,aAEhBkC,EAAgBO,GAC9BR,EAASC,EAAQO,IAGrB,MAAayB,EAAaH,ECXpBjE,EAAMF,IAUZ,SAAgBuE,KACXnE,GAEH,MAAMoE,EAAkBjC,IACtB,MAAMP,EAAUP,EAAgCc,GAAmB,IAInE,YAHqBkC,IAAjBzC,EAAQ0C,OACV1C,EAAQ0C,MAAO,GAEV1C,GAEH2C,EAAmB,CACvBrC,EACAO,EACAb,KAEA9B,aAAgBoC,EAAOQ,YAAoBnB,QAAQZ,OAAO8B,MAC1D,MAAM+B,EAA2BnC,QAAQwB,YACvC,cACA3B,EACAO,GAEF,IAAIgC,EAA4BpC,QAAQwB,YACtC,oBACA3B,GAEGuC,IACHA,EAAU,GACVpC,QAAQC,eAAe,oBAAqBmC,EAASvC,IAEvDuC,EAAQjE,KAAK,CACX0B,OAAAA,EACAyB,SAAUlB,EAAYmB,WACtBhC,QAAAA,EACA4C,KAAAA,KAGEE,EAAoB,CACxBxC,EACAO,EACAkC,EACA/C,KAEA9B,aAAea,OAAO8B,IACtB,IAAImC,EAAkCvC,QAAQwB,YAC5C,uBACA3B,GAEG0C,IACHA,EAAa,GACbvC,QAAQC,eAAe,uBAAwBsC,EAAY1C,IAE7D0C,EAAWpE,KAAK,CACdoB,QAAAA,EACAiD,MAAOF,EACP3D,KAAMqB,QAAQwB,YAAY,oBAAqB3B,GAAQyC,MAI3D,KAAI3E,EAAKY,OAAS,GASlB,gBACEsB,EACAO,EACAkC,GAEA,MAAM/C,EAAUwC,EAAepE,EAAK,IAAM,IAC1C,YAA8B,IAAnB2E,EACFJ,EAAiBrC,EAAQO,EAAab,GAEtC8C,EAAkBxC,EAAQO,EAAakC,EAAgB/C,IAlBlE,CACE,MAAMA,EAAUwC,EAAe,SACR,IAAZpE,EAAK,GACduE,EAAiBvE,EAAK,GAAIA,EAAK,GAAI4B,GAEnC8C,EAAkB1E,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI4B,IAiBnD,MAAakD,EAASX,WC/FNY,KAAa/E,GAC3B,MAAMiC,EAAW,CACfC,EACAyB,KAEAtB,QAAQC,eAAe,wBAAwB,EAAMJ,EAAQyB,GAE7D,MAAMqB,EAAO9C,EAAOyB,EAASC,YACvBqB,aAAsBtB,EAASC,eAE/BsB,EAAmB7C,QAAQwB,YAC/B,oBACA3B,EACAyB,GAEIwB,EAAe9C,QAAQwB,YAAY,cAAe3B,EAAQyB,GA8BhE,MAAO,CACLyB,cAAc,EACdC,YAAY,EACZC,UAAU,EACVlC,MAhCF,WAIE,IAAK8B,EACH,YAAYlC,SAASuC,IAAIJ,GAG3B,GAAIF,UACF,YAAYA,GAGd,MAAMO,EAASnD,QAAQwB,YACrB,oBACA3B,EACAyB,GACA8B,IAAKC,GAAkCC,KAAK3C,SAASuC,IAAIG,IAErDtC,EAAQ4B,EAAKY,KAAKD,QAASH,GAOjC,OANAtC,OAAOC,eAAewC,KAAMV,EAAU,CACpCG,cAAc,EACdC,YAAY,EACZC,UAAU,EACVlC,MAAAA,IAEKA,KAUX,OAAIpD,EAAKY,OAAS,EACTqB,EAASjC,EAAK,GAAIA,EAAK,IAEzB,CAACkC,EAAgByB,IACf1B,EAASC,EAAeyB,GCvDnC,MAAM7D,EAAMF,UAkECiG,EAiBXnD,YAAYoD,EAAwBC,GAhB5BJ,mBAA8BtB,EAErBsB,gBAA2C,GAEpDA,eAAuC,GAI9BA,gBAAqC,GAErCA,wBAA0C,GAE1CA,YAAsC,GAKrDA,KAAKK,kBAAkB,CACrB5D,GAAIyD,EACJjE,QAAS,KAEX+D,KAAKM,UAAU,GAAKN,KAEhBG,IACFH,KAAKK,kBAAkB,CACrB5D,GAAI0D,EAAcpD,YAClBd,QAAS,KAEX+D,KAAKM,UAAU,GAAKH,EACpB5C,OAAOC,eAAe2C,EAAe,WAAY,CAC/CV,cAAc,EACdC,YAAY,EACZC,UAAU,EACVlC,MAAOuC,OAGTzC,OAAOI,oBAAoBwC,EAAcpD,YAAYe,WAClDF,OAAQhC,GACPc,QAAQwB,YACN,uBACAiC,EAAcpD,YAAYe,UAC1BlC,IAGHO,QAAS6B,IACR,MAAM3C,EAAOqB,QAAQwB,YACnB,oBACAiC,EACAnC,GAEF,GAAI3C,EAEF2E,KAAKK,kBAAkB,CACrB9D,OAAQ4D,EACRnC,SAAAA,EACA/B,QAAS,GACTZ,KAAAA,QAEG,CACL,MAAMoB,EAAKC,QAAQwB,YACjB,cACAiC,EACAnC,GAEEvB,EAAG8D,mBAEL9D,EAAG8D,mBAAmBlD,SAAW2C,KAGjCA,KAAKK,kBAAkB,CACrB5D,GAAAA,EACAR,QAAS,SAMrB+D,KAAKI,OAASA,EAGTI,qBACLC,GAeA,OAbAT,KAAKU,mBAAmB7F,KAAK4F,GAC7BlD,OAAOoD,KAAKX,KAAKM,WAAWnE,QAASvB,GACnCoF,KAAKY,eAAeZ,KAAKM,UAAUO,SAASjG,EAAK,OAGnD2C,OAAOsC,OAAOG,KAAKM,WAChBR,IACEgB,GAAa,CAACA,EAAUd,KAAKe,sBAAsBD,KAErD3E,QAAQ,EAAE2E,EAAUE,WACnBA,SAAAA,EAASC,KAAK,IAAMjB,KAAKkB,cAAcJ,KAGpC,KACL,MAAMlG,EAAMoF,KAAKU,mBAAmBS,UACjCC,GAAMA,IAAMX,GAEfT,KAAKU,mBAAmBW,OAAOzG,EAAK,IAIhCgG,eAAehE,GACrBoD,KAAKU,mBAAmBvE,QAASiF,SAAMA,EAAEE,gBAAFF,EAAEE,SAAW1E,IAG9CsE,cAActE,GACpBoD,KAAKU,mBAAmBvE,QAASiF,SAAMA,EAAEG,eAAFH,EAAEG,QAAU3E,IAG7C4E,gBAAgB5E,GACtBoD,KAAKU,mBAAmBvE,QAASiF,SAAMA,EAAEK,iBAAFL,EAAEK,UAAY7E,IAGhD8E,YAAYC,EAAalE,GAC9BuC,KAAK4B,WAAWD,GAAOlE,EAGlBoE,QRpJT,IAA+BzF,EQqJ3BmB,OAAOoD,KAAKX,KAAKM,WAAWnE,QAASwF,IACnC,MAAM/G,EAAMiG,SAASc,EAAK,IACpBxG,EAAW6E,KAAK8B,WAAWlH,GAC5BM,EAAkBC,IACrB6E,KAAK+B,gBAAgBnH,EAAKO,KAG9B6E,KAAKM,UAAY,GAEbN,KAAK5D,WR9JkBA,EQ+JV4D,KAAK5D,SR9JxBP,WDvBAN,EACAjC,GAEA,MAAMsB,EAAMU,EAAYC,ECoBc6F,GAAMA,IAAMhF,GDnBlD,OAAIxB,GAAO,EACF,IAAIW,EAAKyG,MAAM,EAAGpH,MAASW,EAAKyG,MAAMpH,EAAM,IAE9CW,ECgBK0G,CAAcpG,GQ+JtBmE,KAAK5D,cAAWsC,GAIZqD,gBACNnH,EACAO,GAEA,MAAM2F,EAAWd,KAAKM,UAAU1F,GAChC,GAAIkG,EAAU,CACZd,KAAKwB,gBAAgBV,GAErB,MAAM9D,EAAUN,QAAQwB,YACtB,oBACAhD,EAAkBC,GAAYA,EAASE,KAAOF,EAASsB,GAAGqB,WAExDd,GAAY8D,EAAiB9D,IAC9B8D,EAAiB9D,GAASiD,KAAKa,GAEjCd,KAAKM,UAAU1F,QAAe8D,GAI5BwD,yBR7LT,IAA4B9F,EQ8LnB4D,KAAK5D,WACR4D,KAAK5D,SACH+F,IAEkC,mBAAvBA,EACRA,EAA2B9E,SAAW2C,KAEvCA,KAAKK,kBAAkB8B,IAGvBnC,KAAK5D,WRvMbP,EAAUhB,KADgBuB,EQyMR4D,KAAK5D,URvMvBN,EAAgBK,QAAShB,GAAaiB,EAASjB,IAC/CY,EAAeI,QAASe,GAAad,EAASc,MQ2MvCkF,kBAAkBC,GACvB9H,QAAQ+H,KACN,gFAEFtC,KAAKuC,SAAWF,EAGVhC,kBACNmC,GAEA,IAAoD,IAAhDxC,KAAK8B,WAAWtI,QAAQgJ,KAExBA,EAAkBvG,QAAQL,MAC1BN,EACE0E,KAAK8B,WACJ5F,GAASA,EAAKD,QAAQL,OAAS4G,EAAkBvG,QAAQL,OACvD,GAELrB,QAAQ+H,6BACkBE,EAAkBvG,QAAQL,6BAItDoE,KAAKyC,qBAAqBD,GAE1BrI,EACE,uBACAe,EAAkBsH,GACbA,EAAkBnH,KAAaO,KAC/B4G,EAAkB/F,GAAWb,MAEpCoE,KAAK8B,WAAWjH,KAAK2H,GACjBA,EAAkBvG,QAAQyG,OAAO,CACnC,MAAM9H,EAAMoF,KAAK8B,WAAW7G,OAAS,EACrC0H,WAAW,KACT3C,KAAK4C,YAAYJ,EAAmB5H,IACnC,IAKD6H,qBACND,GAEA,GAAKtH,EAAkBsH,GAyBhB,CAEL,MAAMnE,EAAU3B,QAAQwB,YACtB,uBACAsE,EAAkBjG,OAAOQ,YAAYe,WAIvCpB,QAAQC,eACN,uBACA0B,EACAmE,EAAkBnH,KAAKyC,eApCgB,CACzC,MAAMO,EAAU3B,QAAQwB,YACtB,uBACAsE,EAAkB/F,GAAGqB,WAOjB+E,GAJJnG,QAAQwB,YACN,oBACAsE,EAAkB/F,GAAGqB,YAClB,IAC8BgF,KAClC3D,GACCA,EAAON,MACNnC,QAAQwB,YACP,uBACAiB,EAAON,KAAKf,aAGbO,GAAWwE,GACdnG,QAAQC,eACN,wBACA,EACA6F,EAAkB/F,GAAGqB,YAmBtBiF,SAASnG,EAA+BhB,GAC7C,MAAMK,EACJS,QAAQwB,YAAY,oBAAqBtB,IAAc,GACzDoD,KAAKK,kBAAkB,CACrB5D,GAAIG,EACJX,aACKA,GACHL,KAAMA,GAAQK,EAAQL,SAKpBoH,0BACNpG,EACAhB,GAEA,IAAK,IAAIJ,EAAI,EAAGC,EAAIuE,KAAK8B,WAAW7G,OAAQO,EAAIC,EAAGD,IACjD,GAAII,GACF,GAAIA,IAASoE,KAAK8B,WAAWtG,GAAGS,QAAQL,KACtC,OAAOJ,OAGT,GACEwE,KAAKiD,+CACHrG,EACAoD,KAAK8B,WAAWtG,IAGlB,OAAOA,EAIb,OAAQ,EAGFyH,+CACNrG,EACAzB,GAEA,YACuB,IAAdyB,IACN1B,EAAkBC,GAAYA,EAASE,KAAOF,EAASsB,MAAQG,EAI5DsG,4BACNtG,EACAhB,EACAuH,GAQA,MANIvG,IAAchB,IAChBA,EAAQgB,EAAkBhB,MAEvBA,IACHA,EAAO,eAECtB,oBACMsB,eACZuH,OAAsBA,EAAmB,MAKvCC,yBACNjI,GAEA,MAAMkI,EAAyC3G,QAAQwB,YACrD,uBACC/C,EAA+BsB,IAElC,OAAI4G,EACKA,EACJC,KAAK,CAACC,EAAGC,IAAMD,EAAErE,MAAQsE,EAAEtE,OAC3BY,IAAK2D,KACJvE,MAAOc,KAAKgD,0BACVS,EAAUpI,KACVoI,EAAUxH,QAAQL,SAGrBkE,IAAI,EAAGZ,MAAAA,KAAYc,KAAK4C,YAAY5C,KAAK8B,WAAW5C,GAAQA,IAE1D,GAGDwE,YAAYvI,GAClB,YACwC,IAA/BA,EAASc,QAAQ0H,WACxBxI,EAASc,QAAQ0H,UAIbC,mBAAmBzI,GACzB,YAAYyE,IAAIzE,EAASoB,OAAOQ,aAG1B8G,2BAA2B1I,GACjC,MAAMgD,EAAU6B,KAAK4D,mBAAmBzI,GAClC2I,EAAU9D,KAAKe,sBAAsB5C,GAC3C,OAAO/C,QAAQ0I,GAGTlB,YAAezH,EAAsCP,GAC3DT,EAAI,mBAAoBgB,GACxB,IAAI2F,EAAWd,KAAKM,UAAU1F,GAiB9B,OAhBKkG,GAAad,KAAK0D,YAAYvI,KAC7BD,EAAkBC,IACpBhB,EACE,iCACAgB,EAASE,KAAKO,KACdT,EAASc,SAGX6E,EADgBd,KAAK4D,mBAAmBzI,GACrBA,EAAS6C,YAC5BgC,KAAKM,UAAU1F,GAAOkG,GAEtBA,EAAWd,KAAK+D,gBAAgB5I,EAAUP,GAE5CoF,KAAKY,eAAeE,IAEtB3G,EAAI,yBAA0BgB,EAAU2F,GACjCA,EAGDkD,sBACNlD,EACArD,GAEIA,GACFf,QAAQC,eAAe,0BAA2Bc,EAAOqD,GAIrDC,sBAAsBD,GAC5B,OAAOpE,QAAQwB,YAAY,0BAA2B4C,GAGhDiD,gBAAmB5I,EAA6BP,GACjDoF,KAAKiE,gBAAgB9I,IACxB6E,KAAKkD,4BACH/H,EAASsB,QACTiC,qBACmBvD,EAASc,QAAQiI,yBAGxC/J,EAAI,oBAAqBgB,EAASsB,GAAGb,KAAMT,EAASc,SACpD,MAEM6E,EAAW,IAAI/D,EAFiB5B,EAASsB,OAC5BuD,KAAKoD,yBAAyBjI,IAIjD6E,KAAKM,UAAU1F,GAAOkG,EACtBd,KAAKmE,mBAAmBrD,GAAU,EAAO3F,GACzC,MAAMiJ,EAAe1H,QAAQwB,YAC3B,iBACA/C,EAASsB,GAAGqB,WAGd,OADAkC,KAAKqE,oBAAoBvD,EAAUsD,EAAMjJ,GAClC2F,EAGDwD,0BACNnJ,GAEA,MAAM2D,EAA4BpC,QAAQwB,YACxC,oBACA/C,EAASsB,GAAGqB,WAEd,GAAIgB,GAC2BA,EAAQgE,KAClC3D,GACCzC,QAAQwB,YACN,uBACAiB,EAAON,KAAKf,YAIhB,OAAOQ,QAAQiG,IACbzF,EAAQgB,IAAKX,IACX,MAAOhE,EAAUP,GAAOoF,KAAKwE,2BAA2BrF,GAClD2B,EAAW5F,EAAkBC,GAC/B6E,KAAK4D,mBAAmBzI,GACxB6E,KAAK4C,YAAYzH,EAAUP,GAC/B,YAAYmG,sBAAsBD,MAQpCmD,gBAAgB9I,GACtB,OACGA,EAASc,QAAQiI,OAClB9I,QAAQD,EAASc,QAAQiI,OAASlE,KAAKyE,OAAOtJ,EAASc,QAAQiI,QAI5D5G,kBAAqBjD,EAAiBkC,GAC3C,MAAMpB,EAA8B,CAAEsB,GAAIF,EAAQN,QAAS,IAKrD6E,EAAW,IAAIvE,KAAUlC,KAJZ2F,KAAKoD,yBAAyB,CAC/C3G,GAAIF,EACJN,QAAS,MAGX+D,KAAKmE,mBAAmBrD,GAAU,EAAM3F,GAExC,MAAMiJ,EAAe1H,QAAQwB,YAC3B,iBACA3B,EAAOuB,WAGT,OADAkC,KAAKqE,oBAAoBvD,EAAUsD,EAAMjJ,GAClC2F,EAGDuD,oBACNvD,EACAsD,EACAjJ,GAEA,MAAM2I,EAAU9D,KAAKsE,0BAA0BnJ,GAC3CiJ,EAEApE,KAAKgE,sBACHlD,EAFAgD,EAGAA,EACG7C,KAAK,IAAMH,EAASsD,GAAMnE,KAAKa,IAAaxC,QAAQoG,WACpDzD,KAAK,IAAMjB,KAAKkB,cAAcJ,KAKhCA,EAASsD,GAAMnE,KAAKa,IAAaxC,QAAQoG,WAAWzD,KAAK,IACxDjB,KAAKkB,cAAcJ,KAIhBgD,GAETA,EAAQ7C,KAAK,IAAMjB,KAAKkB,cAAcJ,IACtCd,KAAKgE,sBAAsBlD,EAAUgD,IAErC9D,KAAKkB,cAAcJ,GAIfqD,mBACNrD,EACA6D,EACAnC,GAEA,MAAM1D,EAA4BpC,QAAQwB,YACxC,oBACAsE,EAAkB/F,GAAGqB,WAEvB,GAAIgB,EACF,IAAK,MAAMK,KAAUL,EACnB3E,EAAI,kBAAmB2G,EAAS/D,YAAYnB,KAAMuD,EAAOnB,UAEvDmB,EAAOlD,QAAQL,WACiC,SAApCgG,WAAWzC,EAAOlD,QAAQL,MAEtCkF,EAAS3B,EAAOnB,UAAYgC,KAAK4B,WAAWzC,EAAOlD,QAAQL,MAE3DoE,KAAK4E,iBACH9D,EACA6D,EACAxF,EACAqD,GAOFoC,iBACN9D,EACA6D,EACAxF,EACAqD,GAEA,IAAIxC,KAAK6E,eAAe/D,EAAU3B,GASlC,GALyBa,KAAK8E,6BAA6B3F,KAGnCA,EAAOlD,QAAQ0C,OAAQQ,EAAOlD,QAAQ8I,QAkCnD/E,KAAKgF,wBAAwB7F,GACtCa,KAAKiF,4BAA4BnE,EAAU3B,GAE3C2B,EAAS3B,EAAOnB,UAAYgC,KAAKkF,uBAC/B/F,EACAqD,EACAmC,OAtC4B,CAC9B,MAAMQ,EAAOnF,KACbzC,OAAOC,eAAesD,EAAU3B,EAAOnB,SAAU,CAC/CyB,cAAc,EACdC,YAAY,EACZE,MACEzF,EACE,uCACA2G,EAAS/D,YAAYnB,KACrBuD,EAAOnB,UAET,MAAMP,EAAQ0H,EAAKD,uBACjB/F,EACAqD,EACAmC,GAEF,OAAIxF,EAAOlD,QAAQ8I,QACVtH,GAETF,OAAOC,eAAesD,EAAU3B,EAAOnB,SAAU,CAC/C0B,YAAY,EACZjC,MAAAA,IAEFtD,EACE,8CACA2G,EAAS/D,YAAYnB,KACrBuD,EAAOnB,SACP8C,EAAS3B,EAAOnB,WAEX8C,EAAS3B,EAAOnB,eAcvBiH,4BACNnE,EACA3B,GAEA,MAAOhE,GAAY6E,KAAKwE,2BAA2BrF,GACnD,IAAKjE,EAAkBC,GACrB,UAAUb,MACR,mEAIJ,MAAM6D,EAAU6B,KAAK4D,mBAAmBzI,GAClC2I,EAAU9D,KAAKe,sBAAsB5C,GAC3C,IAAIiH,GAAQ,EACRtB,GAEFA,EAAQ7C,KAAK,KACXmE,GAAQ,IAIZ7H,OAAOC,eAAesD,EAAU3B,EAAOnB,SAAU,CAC/CyB,cAAc,EACdC,YAAY,EACZE,MACE,GAAIwF,EAAO,CACT,MAAM3H,EAAQU,EAAQhD,EAAS6C,YAK/B,OAJAT,OAAOC,eAAesD,EAAU3B,EAAOnB,SAAU,CAC/C0B,YAAY,EACZjC,MAAAA,IAEKA,EAET,UAAUnD,MAAM,yDAKd0K,wBAAwB7F,GAC9B,MAAOhE,GAAY6E,KAAKwE,2BAA2BrF,GACnD,QAAOjE,EAAkBC,IACrB6E,KAAK6D,2BAA2B1I,GAI9B2J,6BAA6B3F,GACnC,MAAOhE,GAAY6E,KAAKwE,2BAA2BrF,GAE7CkG,EAAQnK,EAAkBC,GAC5B6E,KAAK6D,2BAA2B1I,GAC/BuB,QAAQwB,YACP,uBACA/C,EAASsB,GAAGqB,WAElB,GAAIuH,GAASlG,EAAOlD,QAAQ8I,QAC1B,UAAUzK,mBACK6E,EAAON,KAAKjD,aAAauD,EAAO5C,OAAOQ,YAAYnB,QAAQuD,EAAOnB,sCAAsCmB,EAAON,KAAKjD,iCAGrI,OAAOyJ,EAGDR,eAAe/D,EAAe3B,GACpC,IAAKa,KAAKuC,SACR,SAEF,MAAO+C,GAAkBtF,KAAKwE,2BAA2BrF,GACzD,GAAImG,EAAgB,CAClB,MAAMvI,EAAc7B,EAAkBoK,GAClCA,EAAejK,KACfiK,EAAe7I,GACnB,GAAIuD,KAAKuC,SAAS/I,QAAQuD,IAAgB,EACxC,SAEF,MAAMwI,EAAWvF,KAAKwF,KAAKzI,GAC3B,GAAIwI,EAEF,OADAzE,EAAS3B,EAAOnB,UAAYuH,KAIhC,SAGME,eAAkB1I,GACxB,IAAKiD,KAAKuC,UAAYvC,KAAKuC,SAAS/I,QAAQuD,IAAgB,EAC1D,OAEF,MAAMwI,EAAW,CACfG,eAAgB,2BAEZC,EAAQ5I,EAAYe,UAQ1B,OAPAP,OAAOI,oBAAoBgI,GAAOxJ,QAAS6B,IACV,mBAApB2H,EAAM3H,KACduH,EAAiBvH,GAAY,YAAa3D,GACzC,OAAOA,MAITkL,QAAJ,EAMKC,KAAQ5I,GACbrC,QAAQ+H,KACN,sEAEF,MAAM1H,EAAMoF,KAAKgD,0BAA0BpG,GAC3C,IAAKoD,KAAKM,UAAU1F,GAAM,CACxB,MAAM4K,EAAOxF,KAAKyF,eAAe7I,GACjC,IAAK4I,EACH,UAAUlL,oCAAoCsC,EAAUhB,MAE1DoE,KAAKM,UAAU1F,GAAO4K,EAExB,YAAYlF,UAAU1F,GAGhB4J,2BACNrF,GAEA,IAAIyG,EAAY5F,KAAKgD,0BACnB7D,EAAON,KACPM,EAAOlD,QAAQL,OAEE,IAAfgK,IACF5F,KAAK6F,6BAA6B1G,GAClCyG,EAAY5F,KAAKgD,0BAA0B7D,EAAON,KAAMM,EAAON,KAAKjD,OAEtE,MAAM0J,EAAiBtF,KAAK8B,WAAW8D,GACvC,IAAKN,EAAgB,CACnB,GAAItF,KAAKI,OACP,YAAYA,OAAOoE,2BAA2BrF,GAGhD,UAAU7E,+BAEN6E,EAAON,KAAKjD,MAAQuD,EAAOlD,QAAQL,cACtBuD,EAAO5C,OAAOQ,YAAYnB,QAAQuD,EAAOnB,aAG5D,MAAO,CAACsH,EAAgBM,GAGlBV,uBACN/F,EACA2G,EACAC,GAEA,MAAO5K,EAAUyK,GAAa5F,KAAKwE,2BAA2BrF,GAgB9D,OAdG4G,GACA5G,EAAOlD,QAAQ8I,SACf7J,EAAkBC,KACnBA,EAASc,QAAQiI,OAChB4B,EAAkB7J,QAAQiI,OAG3B3J,QAAQ+H,mBACQnH,EAASsB,GAAGb,uBAAuBT,EAASc,QAAQiI,6BAC1C4B,EAAkBrJ,GAAGb,+FACaT,EAASc,QAAQiI,cACrE4B,EAAkBrJ,GAAGb,kDAGnBgH,YAAYzH,EAAUyK,GAG5BC,6BAA6B1G,GACnC,GAAIA,EAAON,MAAQM,EAAOlD,QAAQL,KAAM,CACtC,MAAMoK,EAAI,IAAI1L,qCACmB6E,EAAO5C,OAAOQ,YAAYnB,SACnDuD,EAAOnB,8BAA8BmB,EAAOlD,QAAQL,mBAS5D,MAPAzB,EAAI6L,GACJ7L,EACE,uBACA6F,KAAK8B,WAAWhC,IAAKlD,GACnB1B,EAAkB0B,GAAaA,EAAUvB,KAAKO,KAAOgB,EAAUH,GAAGb,OAGhEoK,EAER,IAAK7G,EAAON,MAAQM,EAAOlD,QAAQL,KAAM,CACvC,MAAMoK,EAAI,IAAI1L,qCACmB6E,EAAO5C,OAAOQ,YAAYnB,SACnDuD,EAAOnB,0EAGf,MADA7D,EAAI6L,GACEA,GAMHpG,IAAOqG,EAA4CC,GACxD,IAAItJ,EAC2B,iBAApBqJ,GACTC,EAAOD,EACPrJ,OAAY8B,GAEZ9B,EAAYqJ,EAEd,MAAMrL,EAAMoF,KAAKgD,0BAA0BpG,EAAWsJ,GAChD/K,EAAW6E,KAAK8B,WAAWlH,GACjC,IAAKO,EAAU,CACb,GAAI6E,KAAKI,OACP,YAAYA,OAAOR,IAAIqG,GAEzBjG,KAAKkD,4BAA4BtG,EAAWsJ,GAE9C,YAAYtD,YAAezH,EAAUP,GAGhCuL,eAAkBvJ,GACvB,WAAW0B,QAASoG,IAClB,MAAM0B,EAA0BpG,KAAKQ,qBAAqB,CACxDe,QAAQ8E,GACFA,aAAgBzJ,IAClBwJ,IACA1B,EAAQ2B,OAIdrG,KAAKJ,IAAIhD,KAIN0J,SAAS1J,EAA+B0J,GAC7C,MAAM1L,EAAMoF,KAAKgD,0BAA0BpG,GAC3CoD,KAAKM,UAAU1F,GAAO0L,EACtBnM,EAAI,sBAAuByC,EAAW0J,GAGjCC,SAAS3K,GACd,MAAM4K,EAAOxG,KACb,MAAO,CACLyG,QACED,EAAK/B,OAAO7I,IAAQ,GAEtB8K,eACSF,EAAK/B,OAAO7I,GACnB4K,EAAK1E,WACFlE,OACEzC,IACED,EAAkBC,IAAaA,EAASc,QAAQiI,QAAUtI,GAE9DO,QAAShB,IACR,MAAMP,EAAM4L,EAAKxD,0BACf9H,EAAkBC,GAAYA,EAASE,KAAOF,EAASsB,IAEzD+J,EAAKzE,gBAAgBnH,EAAKO"}